<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title># LLVM IRを触ってみる</title>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<a href="../index.html">トップ(TOP)</a>
<h1 id=" LLVM IRを触ってみる"> LLVM IRを触ってみる</h1>

<p>
先日はLLVM IR Referenceから攻めようとしたがこれを読んだって書けるようになりそうになかったので，その方針は諦めてC言語から実際にLLVM IRのコードを出力しながら触って覚えることにする．
</p>
<h2 id="目次 (Table of Contents)">目次 (Table of Contents)</h2>


<p>
先日はLLVM IR Referenceから攻めようとしたがこれを読んだって書けるようになりそうになかったので，その方針は諦めてC言語から実際にLLVM IRのコードを出力しながら触って覚えることにする．
</p>

<p>
どちらにせよそんなに複雑なコードは書く予定はないのでこれでよいだろう．
</p>

<p>
ここで書いている内容は個人的な解釈が多分に含まれており，おなおかつ勘違いもあると思うのであまり信用せず，最後は自分で責任を持って調べて欲しい．
</p>

<h2 id=" 事前情報として"> 事前情報として</h2>

<p>
LLVMってLLVM-なんとかというの名前がたくさんあるのでその整理を．
</p>

<p>
LLVMはコンパイラの役割の内，機種に依存したり最適化の部分を上手くやってくれる所に相当する．そこで，中間言語を定義しておき一旦中間言語に落とせばそこから先はLLVMがいい感じにアセンブリにまで落としてくれる．(JITとかもできるらしい)

</p>

<p>
LLVM IRがその中間表現にあたる．そしてLLVM IRをテキスト形式にしたものがLLVM Assemblyだ．このテキスト表現は機種に非依存であり，アセンブリでありつつも汎用性を高く書ける．
</p>

<p>
そしてコンパイラを実装する時にどうやってLLVM Assemblyを出力させるかだが，どうやら直接出力するコードを書く(例えばprintfとか使って)ではなく，LLVMのバインディングを使う．
</p>

<p>
つまり構文木を付かって，後はそのライブラリを呼び出して上手くLLVM IRにしてやればAssemblyが出力できるわけだ．とはいえ，今回の自作言語の用途の場合そんな依存関係はなくしたい．
</p>

<p>
LLVMのアップデートに追従できなくなるリスクを取ってでもゴリゴリとprintfで出力することにする．そのためツールの使い方ではなく，自らAssemblyを書けるようにしていく．
</p>

<p>
とはいえ大型のプログラムはさすがにしんどいので，C言語の基本部分がLLVM Assemblyで書けるようになることを目指して学んでいく．
</p>

<p>
その方法はひたすらC言語で色々書いて，それをLLVM Assemblyに変換しその対応関係から学んでいく．
</p>

<p>
また，LLVM Assemblyは長いのでLLVM Assemblyのことをasmと書くのでご注意を．
</p>

<p>
ここではソースコードの記述を除き，コマンド入力している行は先頭に<code>$</code>を付けることとする．
</p>

<h2 id=" まずは簡単なmain関数から"> まずは簡単なmain関数から</h2>

<p>
とりあえず一番シンプルな関数から出力してみる．<code>main.c</code>として以下の内容を記述したファイルを用意する．
</p>

<pre><code>
int main(void){
    return 0;
}
</code></pre>

<p>
そして以下のコマンドでLLVM Assemblyに変換したファイルを作る．
</p>


<pre><code>
$ clang -emit-llvm -O0 -S main.c
</code></pre>

<p>
<code>-emit-llvm</code>はハイフンが一つで正解だ．すると，<code>main.ll</code>が出力される．私の環境の場合その中身は次のようになっている．
</p>

<pre><code>
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Function Attrs: noinline nounwind optnone sspstrong uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  ret i32 0
}

attributes #0 = { noinline nounwind optnone sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{!"clang version 18.1.8"}
</code></pre>

<p>
これがLLVM Assemblyである．
</p>

<p>
前の記事でも書いたが，<code>;</code>はそこから行末までの文字をコメントとして扱う．
</p>

<p>
そして，いらなさそうなのを全部消すとこんな感じ．(根拠はなく多分そんな感じがするぐらいで)

</p>

<pre><code>
define i32 @main(){
  ret i32 0
}
</code></pre>

<p>
LLVMはC言語っぽくもあり，アセンブリっぽくもあるということを聞いていたので，私なりに解釈すると次のようになる．LLVM IR Referenceによると<code>define</code>というキーワードは関数を定義するのに使われるため，main関数を定義しているので間違いないだろう．<code>@main</code>と<code>@</code>がついているのは，これは大域的変数(グローバル変数)を意味している．またC言語で戻り値は<code>int</code>を使っていたので<code>i32</code>というのは<code>int</code>でかつ32bitの幅を持っているのではなかろうか．
</p>

<p>
また，<code>ret</code>というキーワードは<code>return</code>に対応しており，数字の定義は<code>型 数字</code>という並びになっているのであろう．
</p>

<p>
何となくの感じは掴めてきた．<code>ret</code>行の書き方はまさにアセンブリっぽい反面，関数の定義はほぼC言語と言えるだろう．
</p>



<p>
これをアセンブリに変換するには以下のコマンドを使う．
</p>

<pre><code>
$llc main.ll
</code></pre>

<p>
すると<code>main.s</code>という本当のアセンブリが出力される．私の環境では<code>main.s</code>の中身は次のようになった．
</p>

<pre><code>
	.text
	.file	"main.ll"
	.globl	main                            # -- Begin function main
	.p2align	4, 0x90
	.type	main,@function
main:                                   # @main
	.cfi_startproc
# %bb.0:
	xorl	%eax, %eax
	retq
.Lfunc_end0:
	.size	main, .Lfunc_end0-main
	.cfi_endproc
                                        # -- End function
	.section	".note.GNU-stack","",@progbits
</code></pre>

<p>
これをさらにコンパイルして実行可能な形式にするには以下のコマンドを使う．今回は<code>clang</code>を使ったが別に<code>gcc</code>を使ってもよい．
</p>


<pre><code>
$ clang main.s
</code></pre>

<p>
すると私の環境では，<code>a.out</code>というファイルが出力される．これを実行すると何も起こらないプログラムが実行される．
</p>

<pre><code>
$ ./a.out
</code></pre>

<p>
念のため，この出力結果を以下のコマンドで確認すると次のようになった．
</p>

<pre><code>
$ ./a.out
$ echo $?
0
</code></pre>

<p>
つまり終了ステータスは0だ．少しだけ補足すると，私の使っているShellはBashで，直前に実行したプログラムの終了コードは<code>$?</code>という変数に入る．なのでその結果を<code>echo</code>で確認するというのが上のコマンドの意味だ．
</p>

<p>
そして終了コードは<code>main.c</code>で言う所の，<code>return 0;</code>に相当する．なので，試しに<code>return -1;</code>とかに変えて実行すると，終了コードも変化する．
</p>

<p>
<code>main.c</code>から変更して試してもいいが，せっかくなので<code>main.ll</code>から修正してみる．
</p>

<p>
終了コードを<code>2</code>に修正してみる．
</p>


<pre><code>
define i32 @main(){
  ret i32 2
}
</code></pre>

<p>
後は同じようにしてこのプログラムをコンパイルして実行してみると次のようになった．
</p>

<pre><code>
$ llc main.ll
$ clang main.s
$ ./a.out
$ echo $?
2
</code></pre>

<p>
この数字を色々変えて遊んでいて初めて知ったのだが，Bashの終了コード範囲は0-255らしく，負の値や256以上の値を入れても正しい数字として表示されず，0-255の範囲に丸められてしまっていた．これはこういうものらしい．
</p>

<p>
ここで疑問に思ったのだが，<code>main</code>関数はなぜ実行されるのだろうか．<code>define</code>というキーワドはあくまで<code>main</code>関数を定義するだけであって，それを実行するわけではない．<code>main</code>関数という名前の関数を定義すればそれは自動的に実行されるようになっているのだろうか．
</p>

<p>
というわけで，<code>main.ll</code>の中身を次のように変更して実行してみた．
</p>

<pre><code>
define i32 @non_main(){
  ret i32 0
}
</code></pre>

<p>
<code>main</code>を<code>non_main</code>にしてみる．すると次のようエラーが出力された．
</p>

<pre><code>
$ llc main.ll
$ clang main.s
(.text+0x1b): undefined reference to `main'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>
どうやら単純に<code>main</code>という関数を実行しているようだ．ちなみに<code>main.s</code>の中身を確認してみると次のようになっていた．
</p>


<pre><code>
	.text
	.file	"main.ll"
	.globl	non_main                        # -- Begin function non_main
	.p2align	4, 0x90
	.type	non_main,@function
non_main:                               # @non_main
	.cfi_startproc
# %bb.0:
	xorl	%eax, %eax
	retq
.Lfunc_end0:
	.size	non_main, .Lfunc_end0-non_main
	.cfi_endproc
                                        # -- End function
	.section	".note.GNU-stack","",@progbits
</code></pre>

<p>
元々のアセンブリコードと見比べると分かるが，違いはラベルが<code>main:</code>か<code>non_main</code>だけだ．つまり，<code>main</code>という名前の関数を定義すれば，自動的にそれが実行されるということでよいのだろう．
</p>

<p>
これで簡単なmain関数から試してみるのはおしまい．
</p>

<p>
次は四則演算をどう書けばよいのかを見ていく．
</p>

<h2 id=" 四則演算の記述方法"> 四則演算の記述方法</h2>

<h2 id=" 変数の記述方法"> 変数の記述方法</h2>

<h2 id=" 関数の定義と呼び出し方法，後は宣言とか"> 関数の定義と呼び出し方法，後は宣言とか</h2>
<br>
<a href="../index.html">トップ(TOP)</a>
</body>
</html>
