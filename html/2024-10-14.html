<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title># LLVM IRを触ってみる</title>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<a href="../index.html">トップ(TOP)</a>
<h1 id=" LLVM IRを触ってみる"> LLVM IRを触ってみる</h1>

<p>
先日はLLVM IR Referenceから攻めようとしたがこれを読んだって書けるようになりそうになかったので，その方針は諦めてC言語から実際にLLVM IRのコードを出力しながら触って覚えることにする．
</p>
<h2 id="目次 (Table of Contents)">目次 (Table of Contents)</h2>


<p>
先日はLLVM IR Referenceから攻めようとしたがこれを読んだって書けるようになりそうになかったので，その方針は諦めてC言語から実際にLLVM IRのコードを出力しながら触って覚えることにする．
</p>

<p>
どちらにせよそんなに複雑なコードは書く予定はないのでこれでよいだろう．
</p>

<p>
ここで書いている内容は個人的な解釈が多分に含まれており，おなおかつ勘違いもあると思うのであまり信用せず，最後は自分で責任を持って調べて欲しい．
</p>

<p>
とりあえず上から順番に試したものを記述していく．
</p>

<p>
まとめて知りたい人は最後の方にまとめて書く予定なのでそこを見て欲しい．
</p>

<h2 id=" 事前情報として"> 事前情報として</h2>

<p>
LLVMってLLVM-なんとかというの名前がたくさんあるのでその整理を．
</p>

<p>
LLVMはコンパイラの役割の内，機種に依存したり最適化の部分を上手くやってくれる所に相当する．そこで，中間言語を定義しておき一旦中間言語に落とせばそこから先はLLVMがいい感じにアセンブリにまで落としてくれる．(JITとかもできるらしい)

</p>

<p>
LLVM IRがその中間表現にあたる．そしてLLVM IRをテキスト形式にしたものがLLVM Assemblyだ．このテキスト表現は機種に非依存であり，アセンブリでありつつも汎用性を高く書ける．
</p>

<p>
そしてコンパイラを実装する時にどうやってLLVM Assemblyを出力させるかだが，どうやら直接出力するコードを書く(例えばprintfとか使って)ではなく，LLVMのバインディングを使う．
</p>

<p>
つまり構文木を付かって，後はそのライブラリを呼び出して上手くLLVM IRにしてやればAssemblyが出力できるわけだ．とはいえ，今回の自作言語の用途の場合そんな依存関係はなくしたい．
</p>

<p>
LLVMのアップデートに追従できなくなるリスクを取ってでもゴリゴリとprintfで出力することにする．そのためツールの使い方ではなく，自らAssemblyを書けるようにしていく．
</p>

<p>
とはいえ大型のプログラムはさすがにしんどいので，C言語の基本部分がLLVM Assemblyで書けるようになることを目指して学んでいく．
</p>

<p>
その方法はひたすらC言語で色々書いて，それをLLVM Assemblyに変換しその対応関係から学んでいく．
</p>

<p>
また，LLVM Assemblyは長いのでLLVM Assemblyのことをasmと書くのでご注意を．
</p>

<p>
ここではソースコードの記述を除き，コマンド入力している行は先頭に<code>$</code>を付けることとする．
</p>

<h2 id=" まずは簡単なmain関数から"> まずは簡単なmain関数から</h2>

<p>
とりあえず一番シンプルな関数から出力してみる．<code>main.c</code>として以下の内容を記述したファイルを用意する．
</p>

<pre><code>
int main(void){
    return 0;
}
</code></pre>

<p>
そして以下のコマンドでLLVM Assemblyに変換したファイルを作る．
</p>


<pre><code>
$ clang -emit-llvm -O0 -S main.c
</code></pre>

<p>
<code>-emit-llvm</code>はハイフンが一つで正解だ．すると，<code>main.ll</code>が出力される．私の環境の場合その中身は次のようになっている．
</p>

<pre><code>
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Function Attrs: noinline nounwind optnone sspstrong uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  ret i32 0
}

attributes #0 = { noinline nounwind optnone sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{!"clang version 18.1.8"}
</code></pre>

<p>
これがLLVM Assemblyである．
</p>

<p>
前の記事でも書いたが，<code>;</code>はそこから行末までの文字をコメントとして扱う．
</p>

<p>
そして，いらなさそうなのを全部消すとこんな感じ．(根拠はなく多分そんな感じがするぐらいで)

</p>

<pre><code>
define i32 @main(){
  ret i32 0
}
</code></pre>

<p>
LLVMはC言語っぽくもあり，アセンブリっぽくもあるということを聞いていたので，私なりに解釈すると次のようになる．LLVM IR Referenceによると<code>define</code>というキーワードは関数を定義するのに使われるため，main関数を定義しているので間違いないだろう．<code>@main</code>と<code>@</code>がついているのは，これは大域的変数(グローバル変数)を意味している．またC言語で戻り値は<code>int</code>を使っていたので<code>i32</code>というのは<code>int</code>でかつ32bitの幅を持っているのではなかろうか．
</p>

<p>
ここで，最近のCPUは64bitマシンなのに何で32bitになっているんだろうと気になった．そこで<code>sizeof(int)</code>を調べてみると4であり，1byte=8bitと解釈すると32bitだった．これはもうそういう仕様だと思うのがよさそうだ．恐らく通常はintは32bitで十分で必要な時に64bitにすればいいということだろう．
</p>

<p>
また，<code>ret</code>というキーワードは<code>return</code>に対応しており，数字の定義は<code>型 数字</code>という並びになっているのであろう．
</p>

<p>
何となくの感じは掴めてきた．<code>ret</code>行の書き方はまさにアセンブリっぽい反面，関数の定義はほぼC言語と言えるだろう．
</p>



<p>
これをアセンブリに変換するには以下のコマンドを使う．
</p>

<pre><code>
$llc main.ll
</code></pre>

<p>
すると<code>main.s</code>という本当のアセンブリが出力される．私の環境では<code>main.s</code>の中身は次のようになった．
</p>

<pre><code>
	.text
	.file	"main.ll"
	.globl	main                            # -- Begin function main
	.p2align	4, 0x90
	.type	main,@function
main:                                   # @main
	.cfi_startproc
# %bb.0:
	xorl	%eax, %eax
	retq
.Lfunc_end0:
	.size	main, .Lfunc_end0-main
	.cfi_endproc
                                        # -- End function
	.section	".note.GNU-stack","",@progbits
</code></pre>

<p>
これをさらにコンパイルして実行可能な形式にするには以下のコマンドを使う．今回は<code>clang</code>を使ったが別に<code>gcc</code>を使ってもよい．
</p>


<pre><code>
$ clang main.s
</code></pre>

<p>
すると私の環境では，<code>a.out</code>というファイルが出力される．これを実行すると何も起こらないプログラムが実行される．
</p>

<pre><code>
$ ./a.out
</code></pre>

<p>
念のため，この出力結果を以下のコマンドで確認すると次のようになった．
</p>

<pre><code>
$ ./a.out
$ echo $?
0
</code></pre>

<p>
つまり終了ステータスは0だ．少しだけ補足すると，私の使っているShellはBashで，直前に実行したプログラムの終了コードは<code>$?</code>という変数に入る．なのでその結果を<code>echo</code>で確認するというのが上のコマンドの意味だ．
</p>

<p>
そして終了コードは<code>main.c</code>で言う所の，<code>return 0;</code>に相当する．なので，試しに<code>return -1;</code>とかに変えて実行すると，終了コードも変化する．
</p>

<p>
<code>main.c</code>から変更して試してもいいが，せっかくなので<code>main.ll</code>から修正してみる．
</p>

<p>
終了コードを<code>2</code>に修正してみる．
</p>


<pre><code>
define i32 @main(){
  ret i32 2
}
</code></pre>

<p>
後は同じようにしてこのプログラムをコンパイルして実行してみると次のようになった．
</p>

<pre><code>
$ llc main.ll
$ clang main.s
$ ./a.out
$ echo $?
2
</code></pre>

<p>
この数字を色々変えて遊んでいて初めて知ったのだが，Bashの終了コード範囲は0-255らしく，負の値や256以上の値を入れても正しい数字として表示されず，0-255の範囲に丸められてしまっていた．これはこういうものらしい．
</p>

<p>
ここで疑問に思ったのだが，<code>main</code>関数はなぜ実行されるのだろうか．<code>define</code>というキーワドはあくまで<code>main</code>関数を定義するだけであって，それを実行するわけではない．<code>main</code>関数という名前の関数を定義すればそれは自動的に実行されるようになっているのだろうか．
</p>

<p>
というわけで，<code>main.ll</code>の中身を次のように変更して実行してみた．
</p>

<pre><code>
define i32 @non_main(){
  ret i32 0
}
</code></pre>

<p>
<code>main</code>を<code>non_main</code>にしてみる．すると次のようエラーが出力された．
</p>

<pre><code>
$ llc main.ll
$ clang main.s
(.text+0x1b): undefined reference to `main'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>
どうやら単純に<code>main</code>という関数を実行しているようだ．ちなみに<code>main.s</code>の中身を確認してみると次のようになっていた．
</p>


<pre><code>
	.text
	.file	"main.ll"
	.globl	non_main                        # -- Begin function non_main
	.p2align	4, 0x90
	.type	non_main,@function
non_main:                               # @non_main
	.cfi_startproc
# %bb.0:
	xorl	%eax, %eax
	retq
.Lfunc_end0:
	.size	non_main, .Lfunc_end0-non_main
	.cfi_endproc
                                        # -- End function
	.section	".note.GNU-stack","",@progbits
</code></pre>

<p>
元々のアセンブリコードと見比べると分かるが，違いはラベルが<code>main:</code>か<code>non_main</code>だけだ．つまり，<code>main</code>という名前の関数を定義すれば，自動的にそれが実行されるということでよいのだろう．
</p>

<p>
これで簡単なmain関数から試してみるのはおしまい．
</p>

<p>
次に移る前に少しだけ．上記コマンドはこれから何回も実行するので，<code>make</code>で自動化しておく．まず次のようなMakefileを作る．面倒だから全て直書きだ．
</p>

<pre><code>
all: a.out

main.ll: main.c
	clang -emit-llvm -S -O0 main.c

main.s: main.ll
	llc main.ll

a.out: main.s
	clang main.s
</code></pre>

<p>
後は<code>make</code>コマンドを実行するだけでよい．main.llだけ更新した場合でもそこから先のmain.sとa.outのファイルだけ生成される．
</p>




<h2 id=" 引き数有りのmain関数"> 引き数有りのmain関数</h2>

<p>
同じ様に引数有りのバージョンを試してみる．
</p>

<pre><code>
int main(int argc, char *argv[]) { 
    return 0; 
}
</code></pre>

<p>
LLVM Assemblyはこうなった．
</p>

<pre><code>
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Function Attrs: noinline nounwind optnone sspstrong uwtable
define dso_local i32 @main(i32 noundef %0, ptr noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  store i32 0, ptr %3, align 4
  store i32 %0, ptr %4, align 4
  store ptr %1, ptr %5, align 8
  ret i32 0
}

attributes #0 = { noinline nounwind optnone sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{!"clang version 18.1.8"}
</code></pre>

<p>
省略したらこんな感じ．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  ret i32 0
}
</code></pre>

<p>
一応コンパイルは通ったし実行もできた．
</p>

<p>
また，これだけだと分かりにくいので<code>argc</code>を返す場合を考えてみる．
</p>

<pre><code>
int main(int argc, char *argv[]) { 
    return argc; 
}
</code></pre>

<p>
これをそのままコンパイルしてmain関数の部分だけ取り出すとこんな感じになる．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  store i32 0, ptr %3, align 4
  store i32 %0, ptr %4, align 4
  store ptr %1, ptr %5, align 8
  %6 = load i32, ptr %4, align 4
  ret i32 %6
}
</code></pre>

<p>
絶対にこんなにいらない．
</p>

<p>
argcにあたる<code>%0</code>の定義だけ追いかけていくとこんな感じになる．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  %4 = alloca i32, align 4
  store i32 %0, ptr %4, align 4
  %6 = load i32, ptr %4, align 4
  ret i32 %6
}
</code></pre>

<p>
すると<code>%4</code>を定義してから<code>%0</code>を<code>%4</code>に代入し，さらに<code>%4</code>を<code>i32</code>で読み出した結果を<code>%6</code>に入れ，それをretで返却している．ゴチャゴチャしているが結局は%0を返却していることに変化はない．とすると色々省略するとこんな感じだろう．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  ret i32 %0
}
</code></pre>

<p>
これで実行してみると確かに合っている．
</p>

<pre><code>
$ ./a.out aa bb
$ echo $?
3
</code></pre>

<p>
ここから分かることは<code>ptr</code>という変数は<code>void*</code>みたいなものでどんなものであっても受け取れるようになっているっぽい．また変数であっても<code>i32</code>のように解釈して返している．
</p>

<p>
さらに<code>alloca</code>は変数を定義するのに配列のようにメモリを確保している．これは<code>free</code>は必要なくて関数が終了する時に自動的に解放されるのだろう．また，LLVMの変数を定義する時は<code>=</code>を使ってよいが，変数に値を別の変数に代入する場合は<code>store</code>を使うっぽい．
</p>

<p>
これでなんとなくの使い方が分かってきた．
</p>

<p>
次は変数をどう書けばよいのかを見ていく．
</p>

<h2 id=" 変数の定義"> 変数の定義</h2>

<p>
まずは局所的変数から順番に．そしてその他として，<code>static</code>や<code>extern</code>，<code>const</code>について動作を見ていく．
</p>

<h3 id=" 数値の変数"> 数値の変数</h3>

<p>
とりあえず適当に定義してみる．
</p>

<pre><code>
int main(void){
    int a = 10;
    return 0;
}
</code></pre>

<p>
いる所はこんな感じ．
</p>

<pre><code>
define i32 @main() {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  store i32 10, ptr %2, align 4
  ret i32 0
}
</code></pre>

<p>
いつもこの謎の<code>%1</code>が入るがこれは使っていないので変数<code>int a</code>にあたるのは<code>%2</code>であろう．なので変数の定義だけ取り出すとこんな感じ．
</p>

<pre><code>
  %2 = alloca i32, align 4
  store i32 10, ptr %2, align 4
</code></pre>

<p>
これを見ると引数有りの<code>main</code>関数と同じで<code>alloca</code>を使って変数を定義し，<code>store</code>を使って値を代入している．
</p>

<p>
<code>align</code>はアライメントのことで<code>i32</code>で32bitだから4byteのアライメントにしているのだろう．
</p>

<p>
アライメントの話はここでは詳説はしないが，メモリの区切りの話になる．
</p>

<p>
例えば4byteのアライメントのアーキテクチャの場合4byte区切りでメモリが配置されている．intを4byteの変数として，short intが2byte，charが1byteの環境を考える．この時，intの変数だけ定義していれば問題ないが，short intの後にintを定義したとするとアライメント跨ぎが発生する可能性がある．，short intアライメントの最初から2byteを使うが，その次のアライメントはshort intの後2byteだ．ところがその次にintを定義すると，このintはアライメントを跨いで2byteと2byteの合計4byteを使うことになる．アライメントを跨ぐ場合一発でレジストリに読み出せない場合があり，2回読み出して組み合わせるとかする必要がある．賢いコンパイラであればいい感じにしてくれるが，こうした面倒なことが発生するのでアライメントはきっちりと揃えておいた方が変なことは発生しない．
</p>

<pre><code>
例えば||がアライメントだとするとこんな感じ．|| 1byte   | 1byte  | 1byte  | 1byte  || 1byte   | 1byte  | 1byte  | 1byte  ||

intを2個定義するとこうなる
||            int                     ||               int                  ||

short intを2個定義するとこうなる
||  short int       |  short int      || 1byte   | 1byte  | 1byte  | 1byte  ||

short intとintをアライメント跨ぎが発生するように配置した場合
|| short int        |              int                    | 1byte  | 1byte  ||

アライメントを揃えた場合
|| short int        | 1byte  | 1byte  ||               int                  ||
</code></pre>

<p>
次に色々な変数を定義してみる．構造体は後に回すとして単純な数値から．
</p>

<pre><code>
#include <stdint.h>
int main(void) {
  int8_t a = -8;
  int16_t b = -16;
  int32_t c = -32;
  int64_t d = -64;
  uint8_t e = 8;
  uint16_t f = 16;
  uint32_t g = 32;
  uint64_t h = 64;
  float i = 16.0;
  double j = 32.0;
  long double k = 64.0;
  return 0;
}
</code></pre>

<p>
LLVM Assemblyは以下の通り．
</p>


<pre><code>
define i32 @main() {
  %2 = alloca i8, align 1
  %3 = alloca i16, align 2
  %4 = alloca i32, align 4
  %5 = alloca i64, align 8
  %6 = alloca i8, align 1
  %7 = alloca i16, align 2
  %8 = alloca i32, align 4
  %9 = alloca i64, align 8
  %10 = alloca float, align 4
  %11 = alloca double, align 8
  %12 = alloca x86_fp80, align 16
  store i8 -8, ptr %2, align 1
  store i16 -16, ptr %3, align 2
  store i32 -32, ptr %4, align 4
  store i64 -64, ptr %5, align 8
  store i8 8, ptr %6, align 1
  store i16 16, ptr %7, align 2
  store i32 32, ptr %8, align 4
  store i64 64, ptr %9, align 8
  store float 1.600000e+01, ptr %10, align 4
  store double 3.200000e+01, ptr %11, align 8
  store x86_fp80 0xK40058000000000000000, ptr %12, align 16
  ret i32 0
}
</code></pre>

<p>
見れば分かる通りunsignedは存在せず全てintになっている．そこで，こんないじわるをしてみたらどうなるのか試してみた．
</p>

<pre><code>
#include <stdint.h>
int main(void) {
  uint16_t f =UINT16_MAX; 
  return 0;
}
</code></pre>

<pre><code>
define i32 @main() {
  %2 = alloca i16, align 2
  store i16 -1, ptr %2, align 2
  ret i32 0
}
</code></pre>

<p>
C言語の規格上そうなっていたような気もするが，こういう表現もOKということか．
</p>

<h3 id=" 構造体の変数"> 構造体の変数</h3>

<p>
次に構造体の変数を定義してみる．
</p>

<p>
まずはシンプルな1変数を持つ構造体から．
</p>

<pre><code>
struct A {
  int a;
};
int main(void) {
  struct A a = {.a = 0};
  return 0;
}
</code></pre>

<pre><code>
%struct.A = type { i32 }

define i32 @main() {
  %2 = alloca %struct.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 4, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
これだけ見るとほとんどC言語の構造体と同じだとういことが分かる．そして構造体のメモリの確保は通常の変数と同じ<code>alloca</code>を使っているが，構造体の初期化には<code>llvm.memset</code>という関数を宣言して使っていた．
</p>

<p>
複数の要素を持つ場合は次の通り．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
int main(void) {
  struct A a = {0};
  return 0;
}
</code></pre>

<pre><code>
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 8, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
基本は全く同じで，<code>type</code>の中身が増えただけ．
</p>

<p>
さらに構造体の構造体はどのようになっているのかを見てみる．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
struct B {
  int c;
  struct A d;
};
int main(void) {
  struct B b = {0};
  return 0;
}
</code></pre>

<pre><code>
%struct.B = type { i32, %struct.A }
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.B, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 12, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
これもC言語とそっくりで構造体の中に構造体をそのまま入れた構造になっている．
</p>



<p>
次に何か値を代入してみる．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
int main(void) {
  struct A a = {0};
  a.a = 0;
  a.b = 1;
  return 0;
}
</code></pre>

<pre><code>
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 8, i1 false)
  %3 = getelementptr inbounds %struct.A, ptr %2, i32 0, i32 0
  store i32 0, ptr %3, align 4
  %4 = getelementptr inbounds %struct.A, ptr %2, i32 0, i32 1
  store i16 1, ptr %4, align 4
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
<code>getelementptr</code>を使って構造体のメンバにアクセスしているように見える．おそらくポインタの操作をしているのだろう．
</p>

<p>
予想ではi32のアライメントで要素を取得した後，<code>store</code>でi16なのかi32なのかを切り替えている．アライメントと合わせて結構ややこしいことが起こっていそうなのでこの解釈は後に回す．
</p>

<p>
もしかすると何番目の要素にアクセスするためにはアライメントをどうやってとか計算した上でアクセスが必要なのかもしれない．こうなると配列のアクセスの仕方にも絡んでくるので一旦後に．
</p>

<p>
最後に構造体の構造体に代入してみる．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
struct B {
  int c;
  struct A d;
};
int main(void) {
  struct B b = {0};
  b.c = 0;
  b.d.a = 1;
  b.d.b = 2;
  return 0;
}
</code></pre>

<pre><code>
%struct.B = type { i32, %struct.A }
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.B, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 12, i1 false)
  %3 = getelementptr inbounds %struct.B, ptr %2, i32 0, i32 0
  store i32 0, ptr %3, align 4
  %4 = getelementptr inbounds %struct.B, ptr %2, i32 0, i32 1
  %5 = getelementptr inbounds %struct.A, ptr %4, i32 0, i32 0
  store i32 1, ptr %5, align 4
  %6 = getelementptr inbounds %struct.B, ptr %2, i32 0, i32 1
  %7 = getelementptr inbounds %struct.A, ptr %6, i32 0, i32 1
  store i16 2, ptr %7, align 4
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
さっきと一緒で全て<code>getelementptr</code>と<code>store</code>で操作していることが分かる．これの解釈も後回し．
</p>

<h3 id=" 共用体の変数"> 共用体の変数</h3>

<p>
同じように共用体も試してみる．
</p>

<pre><code>
union A {
  int a;
  short int b;
};
int main(void) {
  union A a = {0};
  return 0;
}
</code></pre>

<pre><code>
%union.A = type { i32 }

define i32 @main() {
  %2 = alloca %union.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 4, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
びっくりするぐらい構造体と一緒だが，<code>i32</code>だけ定義されている．
</p>

<p>
一番大きい値だけ使われるのかと思ってこんなことをしてみたらやはりそうだった．
</p>

<pre><code>
union A {
  short int b;
};
</code></pre>

<pre><code>
%union.A = type { i16 }

; Function Attrs: noinline nounwind optnone sspstrong uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca %union.A, align 2
  store i32 0, ptr %1, align 4
  call void @llvm.memset.p0.i64(ptr align 2 %2, i8 0, i64 2, i1 false)
  ret i32 0
}
</code></pre>

<p>
最初に戻って代入の場合はどうなるのかを見てみる．
</p>

<pre><code>
union A {
  int a;
  short int b;
};
int main(void) {
  union A a = {0};
  a.a = 0;
  a.b = 1;
  return 0;
}
</code></pre>

<pre><code>
%union.A = type { i32 }

define i32 @main() {
  %2 = alloca %union.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 4, i1 false)
  store i32 0, ptr %2, align 4
  store i16 1, ptr %2, align 4
  ret i32 0
}
</code></pre>

<p>
これを見ると初期化は違うがそれ以外は直接<code>store</code>しておりその引数が違うだけだ．
</p>


<h3 id=" enumの変数"> enumの変数</h3>

<p>
とりあえず書いてみたがただの変数で，特に何もなかった．全部自分で展開しろとのことだろう．
</p>

<pre><code>
enum E { A, B };
int main(void) {
  enum E e = A;
  return 0;
}
</code></pre>

<pre><code>
define i32 @main() {
  %2 = alloca i32, align 4
  store i32 0, ptr %2, align 4
  ret i32 0
}
</code></pre>

<h3 id=" ポインタの変数"> ポインタの変数</h3>

<p>
次にポインタを見てみる．
</p>

<pre><code>
int main(void) {
  int a = 0;
  int *p = &a;
  return 0;
}
</code></pre>

<pre><code>
define dso_local i32 @main() #0 {
  %2 = alloca i32, align 4
  %3 = alloca ptr, align 8
  store i32 0, ptr %2, align 4
  store ptr %2, ptr %3, align 8
  ret i32 0
}
</code></pre>

<p>
<code>%2</code>が<code>a</code>で，<code>%3</code>が<code>p</code>にあたる．<code>a</code>はそのままだが，<code>p</code>への代入を見てみると，変数<code>%2</code>に対して<code>ptr</code>でアクセスしている．
</p>

<p>
これだけで<code>&a</code>にあたるのだろう．そして，<code>ptr %3</code>に代入している．
</p>

<p>
しかし，ここで疑問に思うのが<code>ptr %2</code>が<code>a</code>のアドレスだとして，<code>ptr %3</code>はなぜアドレスにならないのだろうか．<code>store</code>には何かルールがありそう．後でLLVM IR Referenceを見て追記する．
</p>

<h3 id=" 配列の変数"> 配列の変数</h3>

<pre><code>
int main(void) {
  int a[10] = {0};
  return 0;
}
</code></pre>

<pre><code>
define i32 @main() {
  %2 = alloca [10 x i32], align 16
  call void @llvm.memset.p0.i64(ptr align 16 %2, i8 0, i64 40, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
局所的変数の配列として定義した場合は<code>alloca</code>を使い，その引数が増えるイメージだ．<code>memset</code>については後に回す．
</p>

<p>
まとめて比較するとこんな感じになる．
</p>


<pre><code>
  uint8_t a[10] = {0};
  uint16_t b[10] = {0};
  uint32_t c[10] = {0};
  uint64_t d[10] = {0};
  float e[10] = {0};
  double f[10] = {0};
</code></pre>

<p>
<code>unsigned</code>は<code>int</code>扱いと一緒だろうからこちらだけその通りか確かめた．
</p>


<pre><code>
  %2 = alloca [10 x i8], align 1
  %3 = alloca [10 x i16], align 16
  %4 = alloca [10 x i32], align 16
  %5 = alloca [10 x i64], align 16
  %6 = alloca [10 x float], align 16
  %7 = alloca [10 x double], align 16
</code></pre>


<p>
次に配列の要素にアクセスする方法を見ていく．さっきの続きと見做してもらってよい．
</p>


<pre><code>
  uint8_t aa = a[1];
  uint16_t bb = b[1];
  uint32_t cc = c[1];
  uint64_t dd = d[1];
  float ee = e[1];
  double ff = f[1];
</code></pre>

<pre><code>
  %14 = getelementptr inbounds [10 x i8], ptr %2, i64 0, i64 1
  %15 = load i8, ptr %14, align 1
  store i8 %15, ptr %8, align 1
  %16 = getelementptr inbounds [10 x i16], ptr %3, i64 0, i64 1
  %17 = load i16, ptr %16, align 2
  store i16 %17, ptr %9, align 2
  %18 = getelementptr inbounds [10 x i32], ptr %4, i64 0, i64 1
  %19 = load i32, ptr %18, align 4
  store i32 %19, ptr %10, align 4
  %20 = getelementptr inbounds [10 x i64], ptr %5, i64 0, i64 1
  %21 = load i64, ptr %20, align 8
  store i64 %21, ptr %11, align 8
  %22 = getelementptr inbounds [10 x float], ptr %6, i64 0, i64 1
  %23 = load float, ptr %22, align 4
  store float %23, ptr %12, align 4
  %24 = getelementptr inbounds [10 x double], ptr %7, i64 0, i64 1
  %25 = load double, ptr %24, align 8
  store double %25, ptr %13, align 8
</code></pre>

<p>
構造体の時と同じく<code>getelemptr</code>が出てきた．<code>inbouds</code>は今回が固定のアドレスだから範囲を指定できるという意味だろう．<code>getelementptr</code>自体はあくまでポインタを返すだけだから，<code>load</code>で読み出して<code>store</code>でセットしている．
</p>

<p>
ここで分からないのが，<code>getelementptr</code>の最後の引数で，これが何番目の要素を取るのかに対応しているはず．そうなると，<code>ptr %2</code>などで渡された値の型が何かによってアドレスは変化するはずだ．しかしそれっぽい型の指定は<code>inbounds</code>ぐらいでそれ以外の引数が存在していない．<code>inbounds</code>の指定を読んでいい感じにしているということだろうか．このあたりもLLVM IR Referenceを読み込む必要がありそうだ．
</p>

<p>
今度はさらに続きで値の書き込みを見てみる．
</p>

<pre><code>
  a[2] = 1;
  b[2] = 1;
  c[2] = 1;
  d[2] = 1;
  e[2] = 1;
  f[2] = 1;
</code></pre>

<pre><code>
  %26 = getelementptr inbounds [10 x i8], ptr %2, i64 0, i64 2
  store i8 1, ptr %26, align 1
  %27 = getelementptr inbounds [10 x i16], ptr %3, i64 0, i64 2
  store i16 1, ptr %27, align 4
  %28 = getelementptr inbounds [10 x i32], ptr %4, i64 0, i64 2
  store i32 1, ptr %28, align 8
  %29 = getelementptr inbounds [10 x i64], ptr %5, i64 0, i64 2
  store i64 1, ptr %29, align 16
  %30 = getelementptr inbounds [10 x float], ptr %6, i64 0, i64 2
  store float 1.000000e+00, ptr %30, align 8
  %31 = getelementptr inbounds [10 x double], ptr %7, i64 0, i64 2
  store double 1.000000e+00, ptr %31, align 16
</code></pre>

<p>
<code>getelementptr</code>の使い方自体は全く一緒．違いは<code>store</code>になっているぐらいだ．
</p>

<h3 id=" 関数ポインタ"> 関数ポインタ</h3>


<h2 id=" 四則演算の記述方法"> 四則演算の記述方法</h2>

<p>
次は四則演算をどう書けばよいのかを見ていく．題材は次のmain.cだ．
</p>


<pre><code>
int main(void) {
  return 1+2;
}
</code></pre>

<p>
と思ったのだが，<code>-O0</code>指定をしているのに最適化されて<code>ret i32 3</code>になってしまっていた．なので次を試す．
</p>

<pre><code>
int main(void) {
  int a = 2;
  int b = 3;
  int c = a + b;
  return 0;
}
</code></pre>

<pre><code>
define i32 @main() {
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  store i32 2, ptr %2, align 4
  store i32 3, ptr %3, align 4
  %5 = load i32, ptr %2, align 4
  %6 = load i32, ptr %3, align 4
  %7 = add nsw i32 %5, %6
  store i32 %7, ptr %4, align 4
  ret i32 0
}
</code></pre>

<p>
<code>%2</code>が<code>a</code>，<code>%3</code>が<code>b</code>，<code>%4</code>が<code>c</code>にあたる．
</p>

<p>
最初の<code>alloca</code>は変数の確保で，その次の<code>store</code>は<code>a=2, b=3</code>を表している．
</p>

<p>
その次の<code>%5, %6</code>は一度別の変数に移し変えて代入している．見た感じからするに，<code>add</code>のような演算の前は自動的に新しい変数で受けるようになっているっぽい．
</p>

<p>
そして，今回のメインとなる演算がその次の<code>%7</code>に代入している行だ．
</p>

<pre><code>
  %7 = add nsw i32 %5, %6
</code></pre>

<p>
<code>nsw</code>は何を意味しているのか?

</p>

<p>
LLVM IR Referenceを見てみると，
</p>

<pre><code>
add [nuw] [nsw] <ty> <op1>, <op2>
</code></pre>

<p>
のようになっており<code>nuw</code>と<code>nsw</code>が設定できるようになっている．
</p>

<p>
<code>nuw</code>はNo Unsigned Wrapの略で，<code>nsw</code>はNo Signed Wrapの略のようだ．そしてこの指定があるとオーバーフローが発生した場合の値は未定義になる．
</p>

<p>
最適化する場合にオーバーフローが起きないことを明示するためのものっぽい．なので実装する時には外しても問題はないだろう．
</p>


<p>
その後は元々確保していた<code>%4</code>に<code>store</code>して完了．
</p>


<p>
次に片方が変数で片方が値だった場合を見てみる．
</p>

<pre><code>
int main(void) {
  int a = 2;
  int c = a + 3;
  return 0;
}
</code></pre>

<pre><code>
define i32 @main() {
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  store i32 2, ptr %2, align 4
  %4 = load i32, ptr %2, align 4
  %5 = add nsw i32 %4, 3
  store i32 %5, ptr %3, align 4
  ret i32 0
}
</code></pre>

<p>
<code>%2</code>が<code>a</code>に<code>%3</code>が<code>c</code>に対応している．
</p>

<p>
一番の差は<code>add</code>の所で，本来は変数が入っていた所に直接値が入っている．
</p>

<pre><code>
  %5 = add nsw i32 %4, 3
</code></pre>

<p>
アセンブリの場合即値かどうかで命令が変わることがあるが，LLVM Assemblyはそんなことはないようだ．
</p>

<p>
次にかけ算や割り算を見ていく．
</p>

<pre><code>
int main(void) {
  int a = 2;
  int b = 3;
  int c = a + b;
  int d = a - b;
  int e = a * b;
  int f = a / b;
  int g = a % b;
  return 0;
}
</code></pre>

<pre><code>
  %11 = add nsw i32 %9, %10
  %14 = sub nsw i32 %12, %13
  %17 = mul nsw i32 %15, %16
  %20 = sdiv i32 %18, %19
  %23 = srem i32 %21, %22
</code></pre>

<p>
直接値が入っている場合も次の通り．
</p>

<pre><code>
int main(void) {
  int a = 2;
  int c = a + 3;
  int d = a - 3;
  int e = a * 3;
  int f = a / 3;
  int g = a % 3;
  return 0;
}
</code></pre>

<pre><code>
  %9 = add nsw i32 %8, 3
  %11 = sub nsw i32 %10, 3
  %13 = mul nsw i32 %12, 3
  %15 = sdiv i32 %14, 3
  %17 = srem i32 %16, 3
</code></pre>

<p>
まあ予想通り．
</p>

<p>
次に<code>unsigned</code>だった場合を見てみると，
</p>

<pre><code>
int main(void) {
  int a = 2;
  int b = 3;
  int c = a + b;
  int d = a - b;
  int e = a * b;
  int f = a / b;
  int g = a % b;
  return 0;
}
</code></pre>

<pre><code>
  %11 = add i32 %9, %10
  %14 = sub i32 %12, %13
  %17 = mul i32 %15, %16
  %20 = udiv i32 %18, %19
  %23 = urem i32 %21, %22
</code></pre>

<p>
<code>nsw</code>がつくつかないの判断はよく分からないがこんなものなのだろう．(<code>unsigned</code>なので<code>2-3</code>はオーバーフローが発生するから分かるが，なぜ<code>add</code>でも<code>nsw</code>が消えるのか)

</p>


<p>
<code>sdiv</code>と<code>srem</code>の最初の<code>s</code>はsignedで，<code>udiv</code>と<code>urem</code>の最初のuはunsignedの意味だろう．<code>uint64_t</code>の場合は<code>i32</code>が<code>i64</code>に変化するだけ．ただし，<code>mul</code>と<code>add</code>の<code>nsw</code>が消える．<code>int64_t</code>の場合は<code>i32</code>が<code>i64</code>に変化するだけ．ただし，<code>mul</code>と<code>add</code>の<code>nsw</code>が復活．
</p>

<p>
<code>float</code>の場合は

</p>

<pre><code>
  %10 = fadd float %8, %9
  %13 = fsub float %11, %12
  %16 = fmul float %14, %15
  %19 = fdiv float %17, %18
</code></pre>

<p>
<code>double</code>の場合は

</p>

<pre><code>
  %10 = fadd double %8, %9
  %13 = fsub double %11, %12
  %16 = fmul double %14, %15
  %19 = fdiv double %17, %18
</code></pre>

<p>
インクリメントは次のようになった．
</p>

<pre><code>
  %4 = add i32 %3, 1
</code></pre>

<p>
ここまで来れば後は大体予想が付くので次に移る．
</p>

<h2 id=" ビット演算"> ビット演算</h2>

<p>
まずは，AND，OR，NOT，XORを見ていく．
</p>

<pre><code>
int main(void) {
  unsigned int a = 0;
  unsigned int b = 1;
  unsigned int c = a & b;
  unsigned int d = a | b;
  unsigned int e = a ^ b;
  unsigned int f = ~a;
  return 0;
}
</code></pre>

<pre><code>
  %10 = and i32 %8, %9
  %13 = or i32 %11, %12
  %16 = xor i32 %14, %15
  %18 = xor i32 %17, -1
</code></pre>

<p>
ここでNOTが<code>xor &lt;ty&gt; &lt;op1&gt;, -1</code>で表現されているのがおやっと思ったポイントだ．<code>-1</code>なので全て<code>1</code>が立ったものに対してXORを取ることになる．考えてみれば，もし相手側が<code>0</code>であれば<code>1</code>になるし，<code>1</code>であれば<code>0</code>と確かにNOTになっている．
</p>

<p>
次にシフト演算を追加してみる．
</p>

<pre><code>
  unsigned int g = a >> b;
  unsigned int h = a << b;
</code></pre>

<pre><code>
  %23 = lshr i32 %21, %22
  %26 = shl i32 %24, %25
</code></pre>

<p>
あんまり対称的な名前ではないのが気になる．<code>shl</code>はshift leftでいいだろう．<code>lshr</code>はlogical shift rightのことらしい．
</p>

<p>
となるとarithmaticがあるはずなので，試しに<code>int</code>にしてみる．
</p>

<pre><code>
int main(void) {
  int a = -1;
  int b = -2;
  int g = a >> b;
  int h = a << b;
  return 0;
}
</code></pre>

<pre><code>
  %8 = ashr i32 %6, %7
  %11 = shl i32 %9, %10
</code></pre>

<p>
左方向にはいくらシフトしようが符号が問題になることはないが，右方向にシフトする場合は型によって符号が問題になることがある．だから予想通り<code>ashr</code>というarithmatic shift rightになっていた．
</p>


<h2 id=" 型のキャスト"> 型のキャスト</h2>

<h2 id=" 制御構文"> 制御構文</h2>



<h1 id=" まとめ"> まとめ</h1>


<h2 id=" 変数の記述方法"> 変数の記述方法</h2>

<h2 id=" 関数の定義と呼び出し方法，後は宣言とか"> 関数の定義と呼び出し方法，後は宣言とか</h2>
<br>
<a href="../index.html">トップ(TOP)</a>
</body>
</html>
