<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title># LLVM IRを触ってみる</title>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<a href="../index.html">トップ(TOP)</a>
<h1 id=" LLVM IRを触ってみる"> LLVM IRを触ってみる</h1>

<p>
先日はLLVM IR Referenceから攻めようとしたがこれを読んだって書けるようになりそうになかったので，その方針は諦めてC言語から実際にLLVM IRのコードを出力しながら触って覚えることにする．
</p>
<h2 id="目次 (Table of Contents)">目次 (Table of Contents)</h2>

<ul>
<li> || 1byte | 1byte | 1byte | 1byte || 1byte | 1byte | 1byte | 1byte ||
</li>
<li> intを2個定義するとこうなる
</li>
<li> || int || int ||
</li>
<li> short intを2個定義するとこうなる
</li>
<li> || short int | short int || 1byte | 1byte | 1byte | 1byte ||
</li>
<li> short intとintをアライメント跨ぎが発生するように配置した場合
</li>
<li> || short int | int | 1byte | 1byte ||
</li>
<li> アライメントを揃えた場合
</li>
<li> || short int | 1byte | 1byte || int ||
</li>
</ul>
<p>
先日はLLVM IR Referenceから攻めようとしたがこれを読んだって書けるようになりそうになかったので，その方針は諦めてC言語から実際にLLVM IRのコードを出力しながら触って覚えることにする．
</p>

<p>
どちらにせよそんなに複雑なコードは書く予定はないのでこれでよいだろう．
</p>

<p>
ここで書いている内容は個人的な解釈が多分に含まれており，おなおかつ勘違いもあると思うのであまり信用せず，最後は自分で責任を持って調べて欲しい．
</p>

<p>
とりあえず上から順番に試したものを記述していく．
</p>

<p>
まとめて知りたい人は最後の方にまとめて書く予定なのでそこを見て欲しい．
</p>

<h2 id=" 事前情報として"> 事前情報として</h2>

<p>
LLVMってLLVM-なんとかというの名前がたくさんあるのでその整理を．
</p>

<p>
LLVMはコンパイラの役割の内，機種に依存したり最適化の部分を上手くやってくれる所に相当する．そこで，中間言語を定義しておき一旦中間言語に落とせばそこから先はLLVMがいい感じにアセンブリにまで落としてくれる．(JITとかもできるらしい)

</p>

<p>
LLVM IRがその中間表現にあたる．そしてLLVM IRをテキスト形式にしたものがLLVM Assemblyだ．このテキスト表現は機種に非依存であり，アセンブリでありつつも汎用性を高く書ける．
</p>

<p>
そしてコンパイラを実装する時にどうやってLLVM Assemblyを出力させるかだが，どうやら直接出力するコードを書く(例えばprintfとか使って)ではなく，LLVMのバインディングを使う．
</p>

<p>
つまり構文木を付かって，後はそのライブラリを呼び出して上手くLLVM IRにしてやればAssemblyが出力できるわけだ．とはいえ，今回の自作言語の用途の場合そんな依存関係はなくしたい．
</p>

<p>
LLVMのアップデートに追従できなくなるリスクを取ってでもゴリゴリとprintfで出力することにする．そのためツールの使い方ではなく，自らAssemblyを書けるようにしていく．
</p>

<p>
とはいえ大型のプログラムはさすがにしんどいので，C言語の基本部分がLLVM Assemblyで書けるようになることを目指して学んでいく．
</p>

<p>
その方法はひたすらC言語で色々書いて，それをLLVM Assemblyに変換しその対応関係から学んでいく．
</p>

<p>
また，LLVM Assemblyは長いのでLLVM Assemblyのことをasmと書くのでご注意を．
</p>

<p>
ここではソースコードの記述を除き，コマンド入力している行は先頭に<code>$</code>を付けることとする．
</p>

<h2 id=" まずは簡単なmain関数から"> まずは簡単なmain関数から</h2>

<p>
とりあえず一番シンプルな関数から出力してみる．<code>main.c</code>として以下の内容を記述したファイルを用意する．
</p>

<pre><code>
int main(void){
    return 0;
}
</code></pre>

<p>
そして以下のコマンドでLLVM Assemblyに変換したファイルを作る．
</p>


<pre><code>
$ clang -emit-llvm -O0 -S main.c
</code></pre>

<p>
<code>-emit-llvm</code>はハイフンが一つで正解だ．すると，<code>main.ll</code>が出力される．私の環境の場合その中身は次のようになっている．
</p>

<pre><code>
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Function Attrs: noinline nounwind optnone sspstrong uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  ret i32 0
}

attributes #0 = { noinline nounwind optnone sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{!"clang version 18.1.8"}
</code></pre>

<p>
これがLLVM Assemblyである．
</p>

<p>
前の記事でも書いたが，<code>;</code>はそこから行末までの文字をコメントとして扱う．
</p>

<p>
そして，いらなさそうなのを全部消すとこんな感じ．(根拠はなく多分そんな感じがするぐらいで)

</p>

<pre><code>
define i32 @main(){
  ret i32 0
}
</code></pre>

<p>
LLVMはC言語っぽくもあり，アセンブリっぽくもあるということを聞いていたので，私なりに解釈すると次のようになる．LLVM IR Referenceによると<code>define</code>というキーワードは関数を定義するのに使われるため，main関数を定義しているので間違いないだろう．<code>@main</code>と<code>@</code>がついているのは，これは大域的変数(グローバル変数)を意味している．またC言語で戻り値は<code>int</code>を使っていたので<code>i32</code>というのは<code>int</code>でかつ32bitの幅を持っているのではなかろうか．
</p>

<p>
ここで，最近のCPUは64bitマシンなのに何で32bitになっているんだろうと気になった．そこで<code>sizeof(int)</code>を調べてみると4であり，1byte=8bitと解釈すると32bitだった．これはもうそういう仕様だと思うのがよさそうだ．恐らく通常はintは32bitで十分で必要な時に64bitにすればいいということだろう．
</p>

<p>
また，<code>ret</code>というキーワードは<code>return</code>に対応しており，数字の定義は<code>型 数字</code>という並びになっているのであろう．
</p>

<p>
何となくの感じは掴めてきた．<code>ret</code>行の書き方はまさにアセンブリっぽい反面，関数の定義はほぼC言語と言えるだろう．
</p>



<p>
これをアセンブリに変換するには以下のコマンドを使う．
</p>

<pre><code>
$llc main.ll
</code></pre>

<p>
すると<code>main.s</code>という本当のアセンブリが出力される．私の環境では<code>main.s</code>の中身は次のようになった．
</p>

<pre><code>
	.text
	.file	"main.ll"
	.globl	main                            # -- Begin function main
	.p2align	4, 0x90
	.type	main,@function
main:                                   # @main
	.cfi_startproc
# %bb.0:
	xorl	%eax, %eax
	retq
.Lfunc_end0:
	.size	main, .Lfunc_end0-main
	.cfi_endproc
                                        # -- End function
	.section	".note.GNU-stack","",@progbits
</code></pre>

<p>
これをさらにコンパイルして実行可能な形式にするには以下のコマンドを使う．今回は<code>clang</code>を使ったが別に<code>gcc</code>を使ってもよい．
</p>


<pre><code>
$ clang main.s
</code></pre>

<p>
すると私の環境では，<code>a.out</code>というファイルが出力される．これを実行すると何も起こらないプログラムが実行される．
</p>

<pre><code>
$ ./a.out
</code></pre>

<p>
念のため，この出力結果を以下のコマンドで確認すると次のようになった．
</p>

<pre><code>
$ ./a.out
$ echo $?
0
</code></pre>

<p>
つまり終了ステータスは0だ．少しだけ補足すると，私の使っているShellはBashで，直前に実行したプログラムの終了コードは<code>$?</code>という変数に入る．なのでその結果を<code>echo</code>で確認するというのが上のコマンドの意味だ．
</p>

<p>
そして終了コードは<code>main.c</code>で言う所の，<code>return 0;</code>に相当する．なので，試しに<code>return -1;</code>とかに変えて実行すると，終了コードも変化する．
</p>

<p>
<code>main.c</code>から変更して試してもいいが，せっかくなので<code>main.ll</code>から修正してみる．
</p>

<p>
終了コードを<code>2</code>に修正してみる．
</p>


<pre><code>
define i32 @main(){
  ret i32 2
}
</code></pre>

<p>
後は同じようにしてこのプログラムをコンパイルして実行してみると次のようになった．
</p>

<pre><code>
$ llc main.ll
$ clang main.s
$ ./a.out
$ echo $?
2
</code></pre>

<p>
この数字を色々変えて遊んでいて初めて知ったのだが，Bashの終了コード範囲は0-255らしく，負の値や256以上の値を入れても正しい数字として表示されず，0-255の範囲に丸められてしまっていた．これはこういうものらしい．
</p>

<p>
ここで疑問に思ったのだが，<code>main</code>関数はなぜ実行されるのだろうか．<code>define</code>というキーワドはあくまで<code>main</code>関数を定義するだけであって，それを実行するわけではない．<code>main</code>関数という名前の関数を定義すればそれは自動的に実行されるようになっているのだろうか．
</p>

<p>
というわけで，<code>main.ll</code>の中身を次のように変更して実行してみた．
</p>

<pre><code>
define i32 @non_main(){
  ret i32 0
}
</code></pre>

<p>
<code>main</code>を<code>non_main</code>にしてみる．すると次のようエラーが出力された．
</p>

<pre><code>
$ llc main.ll
$ clang main.s
(.text+0x1b): undefined reference to `main'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>
どうやら単純に<code>main</code>という関数を実行しているようだ．ちなみに<code>main.s</code>の中身を確認してみると次のようになっていた．
</p>


<pre><code>
	.text
	.file	"main.ll"
	.globl	non_main                        # -- Begin function non_main
	.p2align	4, 0x90
	.type	non_main,@function
non_main:                               # @non_main
	.cfi_startproc
# %bb.0:
	xorl	%eax, %eax
	retq
.Lfunc_end0:
	.size	non_main, .Lfunc_end0-non_main
	.cfi_endproc
                                        # -- End function
	.section	".note.GNU-stack","",@progbits
</code></pre>

<p>
元々のアセンブリコードと見比べると分かるが，違いはラベルが<code>main:</code>か<code>non_main</code>だけだ．つまり，<code>main</code>という名前の関数を定義すれば，自動的にそれが実行されるということでよいのだろう．
</p>

<p>
これで簡単なmain関数から試してみるのはおしまい．
</p>

<p>
次は引数有りのmain関数

</p>


<h2 id=" 引き数有りのmain関数"> 引き数有りのmain関数</h2>

<p>
同じ様に引数有りのバージョンを試してみる．
</p>

<pre><code>
int main(int argc, char *argv[]) { 
    return 0; 
}
</code></pre>

<p>
LLVM Assemblyはこうなった．
</p>

<pre><code>
; ModuleID = 'main.c'
source_filename = "main.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Function Attrs: noinline nounwind optnone sspstrong uwtable
define dso_local i32 @main(i32 noundef %0, ptr noundef %1) #0 {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  store i32 0, ptr %3, align 4
  store i32 %0, ptr %4, align 4
  store ptr %1, ptr %5, align 8
  ret i32 0
}

attributes #0 = { noinline nounwind optnone sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{!"clang version 18.1.8"}
</code></pre>

<p>
省略したらこんな感じ．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  ret i32 0
}
</code></pre>

<p>
一応コンパイルは通ったし実行もできた．
</p>

<p>
また，これだけだと分かりにくいので<code>argc</code>を返す場合を考えてみる．
</p>

<pre><code>
int main(int argc, char *argv[]) { 
    return argc; 
}
</code></pre>

<p>
これをそのままコンパイルしてmain関数の部分だけ取り出すとこんな感じになる．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  store i32 0, ptr %3, align 4
  store i32 %0, ptr %4, align 4
  store ptr %1, ptr %5, align 8
  %6 = load i32, ptr %4, align 4
  ret i32 %6
}
</code></pre>

<p>
絶対にこんなにいらない．
</p>

<p>
argcにあたる<code>%0</code>の定義だけ追いかけていくとこんな感じになる．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  %4 = alloca i32, align 4
  store i32 %0, ptr %4, align 4
  %6 = load i32, ptr %4, align 4
  ret i32 %6
}
</code></pre>

<p>
すると<code>%4</code>を定義してから<code>%0</code>を<code>%4</code>に代入し，さらに<code>%4</code>を<code>i32</code>で読み出した結果を<code>%6</code>に入れ，それをretで返却している．ゴチャゴチャしているが結局は%0を返却していることに変化はない．とすると色々省略するとこんな感じだろう．
</p>

<pre><code>
define i32 @main(i32 %0, ptr %1) {
  ret i32 %0
}
</code></pre>

<p>
これで実行してみると確かに合っている．
</p>

<pre><code>
$ ./a.out aa bb
$ echo $?
3
</code></pre>

<p>
ここから分かることは<code>ptr</code>という変数は<code>void*</code>みたいなものでどんなものであっても受け取れるようになっているっぽい．また変数であっても<code>i32</code>のように解釈して返している．
</p>

<p>
さらに<code>alloca</code>は変数を定義するのに配列のようにメモリを確保している．これは<code>free</code>は必要なくて関数が終了する時に自動的に解放されるのだろう．また，LLVMの変数を定義する時は<code>=</code>を使ってよいが，変数に値を別の変数に代入する場合は<code>store</code>を使うっぽい．
</p>

<p>
これでなんとなくの使い方が分かってきた．
</p>

<p>
次は変数をどう書けばよいのかを見ていく．
</p>

<h2 id=" 変数の定義"> 変数の定義</h2>

<h3 id=" 数値の変数"> 数値の変数</h3>

<p>
とりあえず適当に定義してみる．
</p>

<pre><code>
int main(void){
    int a = 10;
    return 0;
}
</code></pre>

<p>
いる所はこんな感じ．
</p>

<pre><code>
define i32 @main() {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  store i32 0, ptr %1, align 4
  store i32 10, ptr %2, align 4
  ret i32 0
}
</code></pre>

<p>
いつもこの謎の<code>%1</code>が入るがこれは使っていないので変数<code>int a</code>にあたるのは<code>%2</code>であろう．なので変数の定義だけ取り出すとこんな感じ．
</p>

<pre><code>
  %2 = alloca i32, align 4
  store i32 10, ptr %2, align 4
</code></pre>

<p>
これを見ると引数有りの<code>main</code>関数と同じで<code>alloca</code>を使って変数を定義し，<code>store</code>を使って値を代入している．
</p>

<p>
<code>align</code>はアライメントのことで<code>i32</code>で32bitだから4byteのアライメントにしているのだろう．
</p>

<p>
アライメントの話はここでは詳説はしないが，メモリの区切りの話になる．
</p>

<p>
例えば4byteのアライメントのアーキテクチャの場合4byte区切りでメモリが配置されている．intを4byteの変数として，short intが2byte，charが1byteの環境を考える．この時，intの変数だけ定義していれば問題ないが，short intの後にintを定義したとするとアライメント跨ぎが発生する可能性がある．，short intアライメントの最初から2byteを使うが，その次のアライメントはshort intの後2byteだ．ところがその次にintを定義すると，このintはアライメントを跨いで2byteと2byteの合計4byteを使うことになる．アライメントを跨ぐ場合一発でレジストリに読み出せない場合があり，2回読み出して組み合わせるとかする必要がある．賢いコンパイラであればいい感じにしてくれるが，こうした面倒なことが発生するのでアライメントはきっちりと揃えておいた方が変なことは発生しない．
</p>

<pre><code>
例えば||がアライメントだとするとこんな感じ．------------------------------------------------------------------------------
<h2 id="|| 1byte   | 1byte  | 1byte  | 1byte  || 1byte   | 1byte  | 1byte  | 1byte  ||">|| 1byte   | 1byte  | 1byte  | 1byte  || 1byte   | 1byte  | 1byte  | 1byte  ||</h2>
<h2 id="intを2個定義するとこうなる">intを2個定義するとこうなる</h2>
<h2 id="||            int                     ||               int                  ||">||            int                     ||               int                  ||</h2>
<h2 id="short intを2個定義するとこうなる">short intを2個定義するとこうなる</h2>
<h2 id="||  short int       |  short int      || 1byte   | 1byte  | 1byte  | 1byte  ||">||  short int       |  short int      || 1byte   | 1byte  | 1byte  | 1byte  ||</h2>
<h2 id="short intとintをアライメント跨ぎが発生するように配置した場合">short intとintをアライメント跨ぎが発生するように配置した場合</h2>
<h2 id="|| short int        |              int                    | 1byte  | 1byte  ||">|| short int        |              int                    | 1byte  | 1byte  ||</h2>
<h2 id="アライメントを揃えた場合">アライメントを揃えた場合</h2>
<h2 id="|| short int        | 1byte  | 1byte  ||               int                  ||">|| short int        | 1byte  | 1byte  ||               int                  ||</h2>
</code></pre>

<p>
次に色々な変数を定義してみる．構造体は後に回すとして単純な数値から．
</p>

<pre><code>
#include <stdint.h>
int main(void) {
  int8_t a = -8;
  int16_t b = -16;
  int32_t c = -32;
  int64_t d = -64;
  uint8_t e = 8;
  uint16_t f = 16;
  uint32_t g = 32;
  uint64_t h = 64;
  float i = 16.0;
  double j = 32.0;
  long double k = 64.0;
  return 0;
}
</code></pre>

<p>
LLVM Assemblyは以下の通り．
</p>


<pre><code>
define i32 @main() {
  %2 = alloca i8, align 1
  %3 = alloca i16, align 2
  %4 = alloca i32, align 4
  %5 = alloca i64, align 8
  %6 = alloca i8, align 1
  %7 = alloca i16, align 2
  %8 = alloca i32, align 4
  %9 = alloca i64, align 8
  %10 = alloca float, align 4
  %11 = alloca double, align 8
  %12 = alloca x86_fp80, align 16
  store i8 -8, ptr %2, align 1
  store i16 -16, ptr %3, align 2
  store i32 -32, ptr %4, align 4
  store i64 -64, ptr %5, align 8
  store i8 8, ptr %6, align 1
  store i16 16, ptr %7, align 2
  store i32 32, ptr %8, align 4
  store i64 64, ptr %9, align 8
  store float 1.600000e+01, ptr %10, align 4
  store double 3.200000e+01, ptr %11, align 8
  store x86_fp80 0xK40058000000000000000, ptr %12, align 16
  ret i32 0
}
</code></pre>

<p>
見れば分かる通りunsignedは存在せず全てintになっている．そこで，こんないじわるをしてみたらどうなるのか試してみた．
</p>

<pre><code>
#include <stdint.h>
int main(void) {
  uint16_t f =UINT16_MAX; 
  return 0;
}
</code></pre>

<pre><code>
define i32 @main() {
  %2 = alloca i16, align 2
  store i16 -1, ptr %2, align 2
  ret i32 0
}
</code></pre>

<p>
C言語の規格上そうなっていたような気もするが，こういう表現もOKということか．
</p>

<h3 id=" 構造体の変数"> 構造体の変数</h3>

<p>
次に構造体の変数を定義してみる．
</p>

<p>
まずはシンプルな1変数を持つ構造体から．
</p>

<pre><code>
struct A {
  int a;
};
int main(void) {
  struct A a = {.a = 0};
  return 0;
}
</code></pre>

<pre><code>
%struct.A = type { i32 }

define i32 @main() {
  %2 = alloca %struct.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 4, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
これだけ見るとほとんどC言語の構造体と同じだとういことが分かる．そして構造体のメモリの確保は通常の変数と同じ<code>alloca</code>を使っているが，構造体の初期化には<code>llvm.memset</code>という関数を宣言して使っていた．
</p>

<p>
複数の要素を持つ場合は次の通り．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
int main(void) {
  struct A a = {0};
  return 0;
}
</code></pre>

<pre><code>
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 8, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
基本は全く同じで，<code>type</code>の中身が増えただけ．
</p>

<p>
さらに構造体の構造体はどのようになっているのかを見てみる．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
struct B {
  int c;
  struct A d;
};
int main(void) {
  struct B b = {0};
  return 0;
}
</code></pre>

<pre><code>
%struct.B = type { i32, %struct.A }
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.B, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 12, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
これもC言語とそっくりで構造体の中に構造体をそのまま入れた構造になっている．
</p>



<p>
次に何か値を代入してみる．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
int main(void) {
  struct A a = {0};
  a.a = 0;
  a.b = 1;
  return 0;
}
</code></pre>

<pre><code>
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 8, i1 false)
  %3 = getelementptr inbounds %struct.A, ptr %2, i32 0, i32 0
  store i32 0, ptr %3, align 4
  %4 = getelementptr inbounds %struct.A, ptr %2, i32 0, i32 1
  store i16 1, ptr %4, align 4
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
<code>getelementptr</code>を使って構造体のメンバにアクセスしているように見える．おそらくポインタの操作をしているのだろう．
</p>

<p>
予想ではi32のアライメントで要素を取得した後，<code>store</code>でi16なのかi32なのかを切り替えている．アライメントと合わせて結構ややこしいことが起こっていそうなのでこの解釈は後に回す．
</p>

<p>
もしかすると何番目の要素にアクセスするためにはアライメントをどうやってとか計算した上でアクセスが必要なのかもしれない．こうなると配列のアクセスの仕方にも絡んでくるので一旦後に．
</p>

<p>
最後に構造体の構造体に代入してみる．
</p>

<pre><code>
struct A {
  int a;
  short int b;
};
struct B {
  int c;
  struct A d;
};
int main(void) {
  struct B b = {0};
  b.c = 0;
  b.d.a = 1;
  b.d.b = 2;
  return 0;
}
</code></pre>

<pre><code>
%struct.B = type { i32, %struct.A }
%struct.A = type { i32, i16 }

define i32 @main() {
  %2 = alloca %struct.B, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 12, i1 false)
  %3 = getelementptr inbounds %struct.B, ptr %2, i32 0, i32 0
  store i32 0, ptr %3, align 4
  %4 = getelementptr inbounds %struct.B, ptr %2, i32 0, i32 1
  %5 = getelementptr inbounds %struct.A, ptr %4, i32 0, i32 0
  store i32 1, ptr %5, align 4
  %6 = getelementptr inbounds %struct.B, ptr %2, i32 0, i32 1
  %7 = getelementptr inbounds %struct.A, ptr %6, i32 0, i32 1
  store i16 2, ptr %7, align 4
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
さっきと一緒で全て<code>getelementptr</code>と<code>store</code>で操作していることが分かる．これの解釈も後回し．
</p>

<h3 id=" 共用体の変数"> 共用体の変数</h3>

<p>
同じように共用体も試してみる．
</p>

<pre><code>
union A {
  int a;
  short int b;
};
int main(void) {
  union A a = {0};
  return 0;
}
</code></pre>

<pre><code>
%union.A = type { i32 }

define i32 @main() {
  %2 = alloca %union.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 4, i1 false)
  ret i32 0
}
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1
</code></pre>

<p>
びっくりするぐらい構造体と一緒だが，<code>i32</code>だけ定義されている．
</p>

<p>
一番大きい値だけ使われるのかと思ってこんなことをしてみたらやはりそうだった．
</p>

<pre><code>
union A {
  short int b;
};
</code></pre>

<pre><code>
%union.A = type { i16 }

; Function Attrs: noinline nounwind optnone sspstrong uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca %union.A, align 2
  store i32 0, ptr %1, align 4
  call void @llvm.memset.p0.i64(ptr align 2 %2, i8 0, i64 2, i1 false)
  ret i32 0
}
</code></pre>

<p>
最初に戻って代入の場合はどうなるのかを見てみる．
</p>

<pre><code>
union A {
  int a;
  short int b;
};
int main(void) {
  union A a = {0};
  a.a = 0;
  a.b = 1;
  return 0;
}
</code></pre>

<pre><code>
%union.A = type { i32 }

define i32 @main() {
  %2 = alloca %union.A, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %2, i8 0, i64 4, i1 false)
  store i32 0, ptr %2, align 4
  store i16 1, ptr %2, align 4
  ret i32 0
}
</code></pre>

<p>
これを見ると初期化は違うがそれ以外は直接<code>store</code>しておりその引数が違うだけだ．
</p>


<h3 id=" enumの変数"> enumの変数</h3>

<p>
とりあえず書いてみたがただの変数で，特に何もなかった．全部自分で展開しろとのことだろう．
</p>

<pre><code>
enum E { A, B };
int main(void) {
  enum E e = A;
  return 0;
}
</code></pre>

<pre><code>
define i32 @main() {
  %2 = alloca i32, align 4
  store i32 0, ptr %2, align 4
  ret i32 0
}
</code></pre>



<h3 id=" ポインタの変数"> ポインタの変数</h3>

<p>
最後にポインタを見てみる．
</p>

<pre><code>
int main(void) {
  int a = 0;
  int *p = &a;
  return 0;
}
</code></pre>

<pre><code>
define dso_local i32 @main() #0 {
  %2 = alloca i32, align 4
  %3 = alloca ptr, align 8
  store i32 0, ptr %2, align 4
  store ptr %2, ptr %3, align 8
  ret i32 0
}
</code></pre>

<p>
<code>%2</code>が<code>a</code>で，<code>%3</code>が<code>p</code>にあたる．<code>a</code>はそのままだが，<code>p</code>への代入を見てみると，変数<code>%2</code>に対して<code>ptr</code>でアクセスしている．
</p>

<p>
これだけで<code>&a</code>にあたるのだろう．そして，<code>ptr %3</code>に代入している．
</p>

<p>
しかし，ここで疑問に思うのが<code>ptr %2</code>が<code>a</code>のアドレスだとして，<code>ptr %3</code>はなぜアドレスにならないのだろうか．<code>store</code>には何かルールがあるのかもしれない．
</p>

<h3 id=" 配列の変数"> 配列の変数</h3>


<h2 id=" 四則演算の記述方法"> 四則演算の記述方法</h2>

<p>
次は四則演算をどう書けばよいのかを見ていく．ここからは一々全部書くのは面倒なので必要な所だけ見ていく．
</p>

<h2 id=" 変数の記述方法"> 変数の記述方法</h2>

<h2 id=" 関数の定義と呼び出し方法，後は宣言とか"> 関数の定義と呼び出し方法，後は宣言とか</h2>
<br>
<a href="../index.html">トップ(TOP)</a>
</body>
</html>
