音を作る言語を作りたい
====

2024/04/03

人工音声や音楽を作る言語を作りたい．

巷では深層学習を使って，人の声をベースに自然な発音をさせたり，
あるいは，ボイスチェンジャーのように声を別の人の声に変換したりと様々な方法がある．

でも，私が作りたいのはもっと人工的で理論的な例えばフォルマントを活用した人工音声作成だ．
なぜならコテコテにチューニングできるからだ．
その上で伸びやかな声で色々としゃべらせたり歌わせたりしてみたい．

その一方で，簡単な作曲とかもしてみたいと考えている．
つまり，作曲で音を作りつつそれを人工音声で歌ってみるとかできたらいいなと．

ここでいくつかやりたいことが見えてくる．
まずは作曲をしたいので，基本的な楽譜を書けるようにする必要がある．

さらに，楽器を割り当てたり，あるいはビブラートとか変調とか，音の大きさを変化させたりだとか，
そうした装飾的なことを後から自在に編集できるようにしたい．

すると，こんなことがしたい．


1. 楽譜を書ける
2. 楽器の音セットを作れる
3. 音量やビブラートなどの修飾を後から追加できる

まあ，ありもののソフトを組み合わせたらできるんだろうけれども，
ここはちょっとオリジナルで作ってみたくなってしまった．

色々とアイディアはあるが，記述方法が面倒臭すぎたり，
理論的にはきれいだけどちょっと実用したくはないだったりで，中々落し所が見つかっていない．

というわけで，せっかくなのでこの記事を使ってそのあたりの考えをまとめていければなと思っている．

まずは最初ということで，これぐらいにしておく．

2024/04/04

音を作る要素はいくつかある．
フーリエ変換から分かる通り，理論上は単純なsin波の組み合わせで全ての音を作ることができる．
しかし，実際にはそんな面倒な手法で音楽を作ったりはしない．

音楽の3要素として上げられるのが以下である．

- リズム
- メロディ
- ハーモニー

ここで問題になるのが，この3つの要素がひっついて音楽になっているため，
この3つを同時に記述する必要があるということだ．

例えば単線律であればその音の高さと長さを順番に書いていくだけでよい．
しかし，ハーモニになったり，あるいはバッハのように複数のメロディが同時進行したり，
さらにはそれらが交差した場合にはどう記述するかが難しい．

なぜなら，単旋律であれば一つの音を記述すれば，基本的にはその後ろにしか音が現れることがない．
つまり記述上前から読んでいって時間を遡ることがない．

したがって，ハーモニーを構成する場合，あるメロディに紐付くものは同時にならすなどブロック構造を持たせる．
そして，異なるメロディを裏で流したい場合には時間を巻き戻して記述をすることが必要になる．
そうしないと，複数のメロディをハーモニーの形で記述するとごちゃごちゃしすぎて何を書いているのか分からなくなるからだ．

しかし，このような記述法はある音楽を表現しようとした時に複数の表現方法があることを意味する．
こういうことを許すとコーディング規約みたいな面倒な流派を作り出してしまうため避けたい．(とはいっても妥協するだろうが)


さて，ここまでは音楽を作るのに必要な要素を説明した．
ここからは，楽器の音を作ることにフォーカスする．

単純に言えばシンセサイザーの真似をすればいいっちゃいいのかもしれない．

楽器の音を作りたい場合，ある音の高さ，長さをした時にどのような形状の波形を生成するかを決めることに他ならない．
更に，楽器に特定の特性があってそれをパラメータで指定したい場合には，上記パラメータに加えてその特性パラメータも含められるようにする必要がある．

こういうことをしたい場合，プログラマー的には横着をしたくなる．
つまり音の高さパラメータfと長さlに対して，数式的に楽器を記述する方法だ．当面はこれを採用することになるだろう．
ただし，実際の楽器の場合特定の音だと共鳴が強まるなど，単にfとlを連結したような単純な音にはならない．
こういうマニアックなこともできるようにはしておきたい．

この場合fやlを含めた複数のパラメータを取得し，ある時刻tにおける波形の振幅を出力する関数を定義できること．
さらに，その関数にtを入力し実際の波形配列を取得するこの2段階に分かれる．

この時シンセイサイザーのようにエンウ゛ェロープを持ってこないと，音と音の繋ぎで信号が連続的でなくなるのでブチッとした強烈な音が発生する．
イメージとしてはパルス波を流し込むようなもので，周波数領域の広い範囲にバツッとパワーが入ってしまう．


次に，音楽を修飾する要素についても説明する．

上記で楽器の要素で実際の波形配列を生成すると書いたが，実際のユースケースを考えると，
楽器の音を入れ換えるのではなくその楽器の音のままでビブラートを入れたり，あるいは音量を連続的に変化させたりといった処理を入れたなくなる．

単純に音量を変化させるだけでよければ，振幅を変化させるだけでよいので，ある関数を掛ければよい．
しかし，周波数領域でビブラートを掛けたいとなるとちょっと面倒なことになる．

一応取得できた配列の間を補完すれば，擬似的に高解像度な信号になるため，その信号をベースにtを揺らすことで擬似的にfを揺らすことができる．

ただより厳密にそして美しく実装するのであれば，上記楽器の音を生成する場合に最初からfをf(t)のように時間に依存して変化するfにしておく方がよい．

この場合，コンパイルする時に初めて楽器の音の詳細が決まるという，中々アクロバティックかつダイナミックなことになる．

単純な音でよければいいが，どんどん音を重ねたりした場合にこれで成立するのかがちょっと心配になる．

とりあえず今日はここまで．
次からは，実際の楽器の記述法，音楽の記述法について触れていきたい．
まだまだ理想のあり方だったり一般論を述べているだけで，中々具体的な実装や仕様にまで踏み込めていないが，
さらに言えばずっと前からメモや頭の中には考えていたことを後追いでチョビチョビ出しているだけだが，
こうやってとりとめもなく書き連ねていくと進んでいる気がしてくる．

2024/04/06

ここからは実際にどんな記述方法がよいのかを考えていく。
音楽の書き方を先に考え、その後に楽器の書き方を考えることにする。

まず音楽については、単旋律の書き方から順番にハーモニーの書き方、複旋律の書き方へと繋げていく。

単旋律については、リズムとメロディを記載することとする。そして音量については装飾という扱いにする。
また、アクセントやスタカートなどある特定の音については特別な装飾とする。

さらに、休符は無音の音とし、ある音の終了は次の音の開始とする。

すると、ある単旋律は音の高さと長さを書き連ねたものとなる。

音の高さは周波数で表してもよいが、後から変調したくなることもあるので、
アルファベットでABCDEFGとし、オクターブシフトをアルファベットの前に、
フラットやシャープ、ダブルフラットやダブルシャープはアルファベットの後に持ってくる。

オクターブシフトの表記方法は真ん中を基準に0とし、下げればマイナス、上げればプラスとする。

つまりこのような感じ。

```
<number>={0|1|2|3|4|5|6|7|8|9}
<pitch>={+|-}?{<number>}+{A|B|C|D|E|F|G}{#|##|b|bb}*
```


音の長さは全音符を1とし、二分音符、四分音符を順番に1/2、1/4と表記する。
また、3連符などは4分音符の3連符であれば1音は12になるので1/12と表記する。
付点については、3/4のように分数で表記する。

タイなどは一旦はなしにし、必要なだけ伸ばすこととする。
したがって全音符より長い音にしたければ2、3のように伸ばしていけばよい。1以上の分数も許される。

まとめるとこんな感じ。

```
<natural number>={1|2|3|4|5|6|7|8|9}
<length>={<natural number>}+{/}?{<natural number>}*
```

ここまでをまとめると，ある単旋律のメロディは次のように記述できる．

```
<single note>=<pitch><length>
<delimiter>={,| }
<simple melody>=<single note>{<delimiter><single note>}*
```

2024/04/07


次にハーモニーの書き方について。


ハーモニーはあるメロディに紐付いて，そのメロディの厚みを増すために鳴らすために使われたりする．
この考えに沿って，次のように記述する

```
<harmoney>={[}<single note>{<delimiter><single note>}*{]}
```

単純に括弧で囲むだけである．
そして重要なことは，このハーモニーの音の長さは，一番最初に記述した音の長さである．

したがって，一番最初の音よりもさらに長い音を書くと次のメロディの音に重なることになる．

ちょっと前に紹介した単旋律の記法では，前の音の終わりが次の音の始まりになる．
すると，例えばちょっとずつ前の音と重ねながら鳴らすとかしようとするとちょっと面倒．

後で出てくる複旋律の記法で対処する手もあるが，こうした場合は同じメロディとして書きたくなる．
そうした場合に使える小手先のテクニックとして，ハーモニーが使える．

一番最初の音を休符にしたハーモニーを作れば，休符は音が鳴らないので休符ベースでメロディを進行させられる．
したがって，音の先頭は規定されるが後ろの長さや重ね方は自由にできる．

これらを合わせると次のようになる．

```
<note>={<single note>|<harmoney>}
<harmony melody>=<note>+
```


今度は複旋律の書き方について．

これはややこしいが，メロディの中にマークを入れ，後からそのマークを参照すると，そのマークの時間を基準にメロディを開始できるようにする．

いってみれば，メロディの中で基準としたい音を選択しマークする．これはメロディの先頭であってもいいし，中間であってもいい．
そして，そのマークを後で参照すると，それ以降に記述されたメロディはマークされた音から重なるように配置される．

この機能により，一つのファイルの中であっても複数のメロディを同時に記述することができる．


```
<label>={a|b|...|Y|Z}+
<mark>={&}<label><delimiter><note>
<jump>={@}<label><delimiter><note>
```

この時，マークされた音とジャンプの音は同じ基準から開始することになる．
より厳密には，ジャンプの音は事前に設定された，単旋律の音の中でマークされた音の開始位置と同じ位置から開始する．
実装が面倒になりそうなので，必ずマークが先に記述されている必要があることにする．

同じラベルのマークが複数現れてはいけないが，同じラベルのジャンプは複数現れてもよい．

これで大体の音楽が作れるようになってきたと思う．
後は修飾と楽器の作り方．
早く楽器の作り方にまでいきたいが，修飾の書き方を終わらせようか．
といっても，後から色々とやりたいことが増えるのと，楽器の作り方を先にしないと説明しにくい部分があるので，
合計で2回か3回書くことになるかも．(最初，楽器の説明の後，まとめ)

今日はここまで．

2024/04/01

あれから少し時間が経ってしまった．

今度は修飾の仕方について説明する．
修飾にはいくつかあるが，タイについては上の音の長さで定義して欲しい．

スラーについてはビブラートと同じく周波数を修飾する応用編の機能の一部として実現する．

そして音の長さに関する所だが，本来の指定した長さ以上に長く，あるいは短く鳴らすが，
その次の音はあくまで本来指定した長さの後に入るという仕様になる．

レガート，スタッカート，スタッカーティッシモについては，それぞれ本来の長さに加えて，修飾長さを追加で指定できるようにする．
その記法は次の通りである．


```
<length articulation note> = <note>{l}<length>
```

またアクセントやマルカートのような音の強さに関する所は，さらに後述の応用編の機能で実現する．


今度からはいよいよ楽器の作り方について説明する．
やっと音作りに入れる．
どんな楽器で演奏するかによって印象が大きく変わるように切っても切り離せない関係にある．
シンセサイザーに近いものになるかもしれないがそれはそれで．

途中でも言ったが，この手法の面倒な所は同じことを複数の方法で実現できる所だ．
とはいえ内部的な処理はどちらかに統一しているかもしれない．


今日はここまで．


2024/04/11

楽器の作り方について説明する．

まず基本的な考え方としてはフーリエ級数展開となる．
要は任意の形状の波形はシンプルなサイン波の合成であると考える．
実際には三角波とかノコギリ波とか有名所はサポートするが，あくまでその組み合わせだけで音を作る．

音の高さについて，音楽では周波数を指定して(実際にはABC...だが)音の高さを決める．
したがって，楽器もその指定された高さの音を出せる必要がある．

ただし，倍音を鳴らすような楽器もあるため，ある高さを指定した際に，その周波数を元に様々な計算が施され，その結果として音が作られることになる．
また，音は単純に周波数だけでなく音量の変化が重要になる．
いわゆるシンセサイザーのエンベロープだ．


ただ，この音の変化は音の修飾時も使うためにできるだけ共通にしておきたい．
さらに，複数の音の組み合わせであるため，ある範囲ではこの音を，別の範囲ではこの音をといったように，グラデーションのように音が変化するようなものも作りたくなる．

ここまでの汎用性を持たせたい場合，数式で書かざるをえなくなる．
逆にここまでの汎用性は音楽を記述する際には必要ないため，少し違う記法を使ってサポートするようにする．

では具体的な記法について説明する．
まず基本となるサイン波は次のように指定する．


```
<sin wave> = {sin}{(}<frequency>{,}<phase>{,}<length>{)}
```

この場合は音量が1で，周波数が`<frequency>`そして位相が`<phase>`，長さが`<length>`の音が鳴る．
この時，音の長さの指定と音楽の長さの指定の基準が一致すると話が面倒になるため，
音楽のテンポ指定と，楽器のテンポ指定は別物とする．
得に楽器の場合の長さの指定は秒などより汎用的なものがよいかもしれない．

そして波を重ねる方法であるが，これはハーモニーの作り方と同じである．

つまり，

```
<wave> = <sin wave> | <harmoney>+
<harmoney>={[}<wave>{<delimiter><wave>}*{]}
```

この時，周波数0のサイン波は休符と同じ役割を担う．
そして，音のズレなどは休符の長さを上手く使って実現する．

ここで注意が必要なのが，音楽の場合の和音と違って，こちらは入れ子でより複雑な音が作れることだ．
つまり，ある波の重ねた結果を使ってさらに別の波を重ねるというとが階層的に実現できる．
(音楽でも実装が上手くいけばこの機能は入れてもいいかと考えている)

次に音の大きさを調整する方法であるが，
これは波同士の掛け算で実現する．

例えば単調に増加する音を実現したい場合には，単調に増加する波形を生成する．
この波を生成する専用の関数を用意するか，ノコギリ波や三角波から上手く作る．
そうしてできた波を`<volume wave>`とした時に，音が変化する波は次のように書ける．

```
<volume changed wave> = <volume wave>{*}<wave>
```

さらに，ビブラートを実現するためには周波数自体を波にする必要がある．
つまり次のようになる．

```
<constant> = <number>+
<frequency> = <constant> | <wave>
```

また，楽器の場合`<frequency>`は固定値ではなく，入力される音の高さが決まって始めて分かる言わば変数のようなものである．
したがって，楽器を作る場合には関数を定義するのと同じように，複数のパラメータを受けとれるようにする．
これは周波数だけでなく音の調整を入れられるようにするためである．

ただし，実際の楽譜にはこの当りの情報を書かなければその楽器で演奏することができないし，
逆にその楽器以外では演奏できないようになってしまうため一長一短である．
したがって，そうした場合には楽譜を上手く分割しておき，それぞれのパートに足して別の楽器を割り当てる法がよいだろう．

ここまでより楽器の定義は次のような関数の形式とする．


```
sound <sound_name>(freq, ...) {
    ...
}
```

引数は任意の数を受け取れる．


これで音を複雑に重ね合わせる方法，音量を変化させる方法，周波数を変化させる方法について説明した．
これだけで任意の音を作り出せるはず．

ただし，楽器の作り方にもある程度お作法があって，
例えば音の開始や終了が波の中途半端な位置から始まった場合，ブチッとした音が鳴ってしまうため，
それを防ぐために最初と最後の音量を絞ったり．

あるいはさらに高度なことをするのであれば，波と波の間をいい感じになめらかな連続的な変化になるように変形させて繋ぎ合わせるなど工夫の余地はある．
ただし，この補完をやろうとするとここで書いたような単純な記法には収まらない可能性が高く，if文によって切り替えるみたいなことが発生するだろう．

今迷っているのが，専用のプログラミングというか入力環境を作るか，もうプログラミング言語として実装してしまうか．

今時前で作っている新しいプログラミング言語を使って，そのプログラムとして解釈できるように変換器を作るか，上手くデコレーションしてそのものとして実行させるのも面白そう．

今日はここまで．


2024/04/15

ここからはいよいよ実装の方向性について説明していく．
とはいってもここからは構想段階でしかなく，こんな風かな〜という程度しかない．

まず，ハーモニーを構成する方法が一番のポイントであり，これは入れ子にできることがポイントである．
さらに，楽器の構成では波形を作り出せることが重要になるし，その上周波数成分にすら関数を定義できる必要がある．

したがって，もはやプログラミング言語を作ることと同じぐらいのことができる必要がある．
ではどんなプログラミング言語であればよいか．

理論的に美しくても書き難くては使えないので，ある程度の妥協は入れる．

まず入れ子の構造だが，これは括弧を使って表現することとする．

さらに，関数の表現だが，


2024/04/17

途中で切れてしまったが，続きを軽く．

関数の表現は二つの方式で迷っている．


```
( func arg1 arg2 arg3 )
func( func arg1 arg2 arg3 )
```

ほぼ好みの問題だし，構文木をどう作るかだけの問題だからどっちでもいいっちゃいい．

さらに，ハーモニーを作る方法と区別するために括弧は別の記法を使っているから，その後の処理も大した違いはない．

もっと細かなことを言えば，逆に直接的な数値と関数を区別したくない．これは周波数を定数にするか時間に応じて変化させるかを切り替える時にできるだけ単純にしたいからである．
つまり，ある定数は常に同じ値を返し続ける関数であると考える．

したがって，関数の呼び出し規則と同じものを適用したい．
ここで大きな問題は，fが定数の場合であっても引数を取らせたいのだ．

つまり，周波数は常にtの関数であることが要請される．
さらに将来のことを考えれば任意の個数の引数を受け付け，自信と関係のない引数は無視するぐらいまでやった方がいいのだろうか？
まあもっと後で考えることにする．

とりあえず方式はあるとして，一旦は馴染みが深いであろう

```
( func arg1 arg2 arg3 )
```

のような記法を採用することとする．(後で心変わりするかも)

さらに周波数にあたる定数および関数については


```
f(t)
```

として時間tの関数であるとする．つまり周波数が440Hzだった場合`440(t)`みたいな関数としても呼び出せるということ．

そして，実際の楽器を作る時にはある周波数を入れた時にどんな音がでるかを定義する．この時の周波数が`f(t)`になるということだ．

これを元に楽器を定義してみる．
まずは一番シンプルなサイン波から．サイン波は単純に以下で書く．

```
sin(f,t, phi)
```

(これは寄与として考えたくなるが，これをC言語で実装しておいて，後から呼び出すのはかなり面倒臭い．
できれば汎用的なプログラミング言語を先に作ってからそちら側で実装したい．)


話が脱線してしまったが，ここで重要なことはfとtとphiがtの関数として捉えられるということだ．
fは周波数なので先程説明した通り，tについてはこれはそのままでtを返す関数．
そしてphiも同じくtの関数であると考える．

勘のいい人は気付いただろうが，tに対してfを与えることだって可能だ．
ただし，そのままだとtは引数を持たない関数として扱われてしまうため，あんまり自由にあれこれはできない．
これをできるようにしたい．後で考えてみよう．


では次にこの倍音を重ねた音は次のように現せる．

```
[ 
    sin(f, t, phi), 
    sin(2*f, t, phi)
]
```

さらに倍音だけ音を半分にしたい場合


```
[ 
    sin(f, t, phi),
    sin(2*f, t, phi) / 2
]
```

```
[ 
    sin(f, t, phi),
    sin(2*f, t, phi) * 0.5
]
```

ただし普通にじゃんじゃか掛けて足してを繰り返してしまうとすぐにオーバーフローを発生させてしまう．
たかだが16bitとか24bitとかしかないし，どちらかによって最大で取れる値そのものが変化してしまう．

そいういうのは面倒臭いので，最大の音量を1とし，それ以下の音しか作れないようにする．
また，音を重ね合わせる場合も自動で音量を下げるなどの工夫が必要かもしれない．

今日はここまで．
修飾について書く予定だったが，実際に色々とサンプルコードを書いてみて，
本当に使えるものになるのかどうかを確かめるほうがいい気がしてきた．

なので次回からは引き続き楽器の作り方や音楽の書き方のサンプルを交えながら実装に落とせる所にまで持っていきたい．















