# LLVM IR Reference

新しいプログラミング言語を作ろうとして，
今回もインタープリターを書こうとしていたんだけれど，
どうせだったらインタープリタの実行マシン（ソフト上の）をLLVMにしてしまえば，
後々コンパイルするにも便利だから，実行マシンをLLVM IRを受け付けるようなものにしようと考えた．

そこでLLVMのリファレンスを読んでいたのだが，英語だとどうしても目が滑るというが，
一文一文は理解できるけれど，別の段に移ったら前の段を忘れるので日本語にしておく．

この原因って，やっぱり言語の理解にリソースが使われて，言語が示す内容そのものにリソースが避けていないからな気がする．
練習をかねながら試しに書いていく．

前編翻訳するつもりはなく，自分が欲しいものだけできたらOKの方針でいく．

## 目的

新しいプログラミング言語を作るので，それに必要な最低限のLLVM IRの文法や書き方を覚える．
変数や関数の定義，あとはスコープの概念と構造体，配列やポインターが扱えればOKかなと考えている．
もちろん基本的な四則演算と制御演算もだ．

もちろん翻訳内容や正確性，最新版に追従しているという保証もないのでご注意を．
さらに，今回の用途で使うので適当なコメントを追加している．

さらに，コード中の英語のコメントは勝手に日本語に変えたりもしている．
なので，コピペして，LLVMのコンパイルができなくても知りません．

## 構文

### 識別子

global識別子とlocal識別子があり，
global識別子は'@'から始まる．local識別子は'%'から始まる．
さらに，3つのフォーマットがあってそれぞれ目的が違う．

1. named valueは`[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*`．クオートで囲ったものとかもいけるらしいが，今回はいらないのでスキップ．
2. unnamed valuesは`[%@][0-9]+`でunsigned numeric valueを使える．一時変数には丁度いいかもしれない．
3. constantsは長くなるので後で

予約語は色々あるので被らないように．でも`@%`で始まる予約語はないので衝突はしないよ．


```
%result = mul i32 %X, 8
%result = shl i32 %X, 3
%0 = shl i32 %X, %X
%1 = shl i32 %0, %0
%result = add i32 %1, %1
```

shlは左シフト演算のことか？
コンマ区切りが独特に感じる．どうせだったらmul，shl，addの後にもコンマを入れたらいいのにしていない．

1. コメントは`;`から始まりその行の終わりまで．
2. unnamedな一時変数は計算結果がnamed変数に代入されない時に使われる．
3. unnamed変数は通常連番が使われる．別にスキップしてもよさげ．

ノート:（下まで読まないと書いてあることが分からなさそうなのでここでは仮）
basic blockと無名関数の引数は0から始まる？


### 文字列定数

文字列は`"`で区切られる．`\`を使ってエスケープすれば全ての文字が扱える．

エスケープには2種類あって，


1. `\\`は`\`自身を表す
2. `\`から始まり2つの16進数文字，(0-9, a-f or A-F)はそのbyteの文字を表す


`"`自身を現したい場合は`\22`を使う．

また，文字列は改行によって終了しない．つまり複数行を受け取る．
(この場合改行は改行文字として入るのだろうか，それとも無視されるのだろうか)


## 高度な構造

### Module構造

LLVMのプログラムはModuleの集まりである．
それぞれのmoduleには関数，グローバル変数，シンボルテーブルの要素が入っている．
そしてmodule同士はLLVM linkerによって繋げられる．
前方宣言とかシンボルテーブル要素の結合とかもいい感じにしてくれる．


hello worldのmoduleはこんな感じ

```
; グローバル定数で文字列を宣言．
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"

; puts関数を外部宣言
declare i32 @puts(ptr nocapture) nounwind

; main関数を定義
define i32 @main() {
  ; puts関数を呼び出してstdoutに出力
  call i32 @puts(ptr @.str)
  ret i32 0
}

; 名前付きメタデータ
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```

よく分からないものがいくつかある．`private, nounwind`あとコメントにある`named metadata`以下のやつは何を意味しているのか．

また一般に，moduleはグローバル値(関数と変数)のリストからなる．
グローバル値はメモリの場所へのポインタで表される．(上の例では文字配列へのポインターや関数へのポインター)


### リンケージ型

全てのグローバル変数や関数は次の内のどれかのリンケージ型を持つ．
詳細の説明は全部書くと大変なので概要だけ．

- `private`
    - そのmodule内のオブジェクトからアクセスされる．
- `internal`
    - `private`と似ているが，オブジェクトファイルからはローカルシンボルとして見える．(C言語のstaticに相当)
- `avairable_externally`
    - このリンクを持つグローバル値はmoduleのオブジェクトファイルには出力されない．いわゆる外部宣言．定義する時だけ使われる．宣言には使ってはいけない．
- `linkonce`
    - 他のモジュールの同名のグローバル値と同一に見做される．一度も参照されなかった場合破棄されうる．
- `weak`
    - `linkonce`と似ているが，参照がなかった場合でも破棄されない．
- `common`
    - `weak`と似ている．C言語で言う所のグローバルスコープの`int X;`
- `appending`
    - 配列へのポインターのグローバル変数だけに適用される．2つのグローバル変数が一緒にリンクされた場合に，グローバル配列が一緒に追加される．(?)使い道と意味がよく分からなかった．
- `extern_weak`
    - ELFオブジェクトファイルモデルに従う．シンボルはリンクされるまでは`weak`であり，リンクがない場合，そのシンボルは未定義ではなくnullになる．
- `linkonce_odr`, `weak_odr`
    - odrが付くと，すべてのグローバル値が同値であることを意味する．
- `external`
    - 上記の識別子が何も付かなかった場合は，これになる．リンクされた時も外から参照できるように解決される．


宣言する場合，`external`か`extern_weak`以外の指定はルール違反．

## 呼出規約

functions, calls，invokesはオプションを持ちうる．
動的な呼び出し元，呼び出し先の規約は一致している必要がある．さもなければその動作は未定義．
現在サポートされている呼出規約は以下の通りで，今後追加される予定．

- `ccc`
    - C言語の呼出規約で，他のオプションが指定されない限りデフォルトはこれ．
- `fastcc`
- `coldcc`
- `ghccc`
- `cc 11`
- `anyregcc`
- `preserve_mostcc`
- `preserve_allcc`
- `preserve_nonecc`
- `cxx_fast_tlscc`
- `tailllcc`
- `swiftcc`
- `swifttailcc`
- `cfguard_checkcc`
- `cc <n>`


## 表示スタイル

全てのグローバル変数や関数は以下のどれかの表示スタイルを持つ．


- `default`
    - ELFオブジェクトファイルのフォーマットを使う．他のmoduleから宣言が見える．
- `hidden`
    - 同じオブジェクトからは参照できるが，それ以外からは見れない．つまり他のmoduleからは直接参照することができない．
- `protected`
    - シンボルは動的シンボルとして配置されるが，定義されたmodule内ではローカルシンボルとして扱われる．他のmoduleからは上書きできない．


`internal`や`private`としてリンクされた場合は，`defaullt`の表示スタイルに設定しなくてはならない．


## DLLストレージクラス
