# LLVM Assemblyを書けるようになる(LLVM IR Reference)

新しいプログラミング言語を作ろうとして，今回もインタープリターを書こうとしていたんだけれど，
どうせだったらインタープリタの実行マシン（ソフト上の）をLLVMにしてしまえば，
後々コンパイルするにも便利だから，実行マシンをLLVM IRを受け付けるようなものにしようと考えた．

そこでLLVMのリファレンスを読んでいたのだが，英語だとどうしても目が滑るというが，
一文一文は理解できるけれど，別の段に移ったら前の段を忘れるので日本語にしておく．

この原因って，やっぱり言語の理解にリソースが使われて，言語が示す内容そのものにリソースが避けていないからな気がする．
練習をかねながら試しに書いていく．

前編翻訳するつもりはなく，自分が欲しいものだけできたらOKの方針でいく．

あれからリファレンスを見たが，これは読んでもある意味しょうがないような．
LLVM IRの書き方の基礎を学びたいんだけれど，ブログを片っ端から漁って試して学ぶしかないのか．

次の記事ではC言語のソースからLLVM Assemblyに変換しておおよその基本的な所を抑える．
それを踏まえて，この記事が全然役に立たなかったのでLLVM IR Referenceの逐次訳はやめて，
入門書的なものに方向転換することにした．

上から順番に追記していくので繋がらない部分が出てくるかもしれない．

## その前に

LLVM AssemblyはLLVM IRのテキスト表現．

新しいプログラミング言語を作るので，それに必要な最低限のLLVM IRの文法や書き方を覚える．
変数や関数の定義，あとはスコープの概念と構造体，配列やポインターが扱えればOK．
もちろん基本的な四則演算と制御演算もだ．

正確性，最新版に追従しているという保証もないのでご注意を．
さらに，今回の用途で使うので適当なコメントを追加している．

さらに，コードは適当に改変したりしているので一々動作を確認はしていない．
コピペして，LLVMのコンパイルができなくても知りません．

ちなみに本記事では次のコマンドを使ってC言語のソースコードをLLVMに変換している．

```
$ clang -emit-llvm -O0 -S main.c
$ llc main.ll
$ clang main.s
$ ./a.out
```

上記コマンドを実行している環境は以下の通り．
日付はちょっとずれる．

```
CPU: AMD A10-7850K Radeon R7, 12 Compute Cores 4C+8G
OS: ArchLinux(2024/10/20)
```

## 環境構築


本記事の中で使うプログラム

- `llvm`
- `clang`(`gcc`でもよいが今回はこちらで統一)
- `make`

ArchLinuxでは次のコマンドで入れることができる．

```
sudo pacman -S make llvm clang
```

LLVM Assemblyはテキストで書くことができ，その拡張子は`.ll`である．
なので分かりやすく`main.ll`という名前にしておく．

これをアセンブリに変換するには次のようなコマンドを使う．

```
$ llc main.ll
```

これで`main.s`というアセンブリが記述されたテキストファイルが生成される．

さらにこれを`clang`を使って実行可能なファイルに変換する．

```
$ clang main.s
```

環境にもよるがArch Linuxの場合`a.out`というファイルが生成され，
これを実行するとLLVM Assemblyで記述したプログラムを実行することができる．

毎回これを打つのは大変なので，`make`で自動化しておく．


`Makefile`という名前のファイルを作成し，次のように書く．

```
all: a.out

main.s: main.ll
	llc main.ll

a.out: main.s
	clang main.s
```

すると以下のように短縮できる．

```
$ make
$./a.out
```

もちろんこんな感じにまとめればone lineで実行可能だ．

```
$ make && ./a.out
```


## まずは何もしないプログラムから

C言語で何もしないプログラムを書いてみる．


```
int main(void){
  return 0;
}
```

これをLLVM Assemblyで書いてみる．
まずは，`main.ll`というファイル名で次のソースコードを書いてみる．

```
define i32 @main() {
  ret i32 0
}
```

見比べてみるとほぼ同じだ．

`int`は`i32`で`int32_t`と同じで32bitを意味する．

`ret`は`return`を意味しており，`i32 0`は`0`を意味している．



## 構文

### 識別子

global識別子とlocal識別子があり，
global識別子は'@'から始まる．local識別子は'%'から始まる．
さらに，3つのフォーマットがあってそれぞれ目的が違う．

1. named valueは`[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*`．クオートで囲ったものとかもいけるらしいが，今回はいらないのでスキップ．
2. unnamed valuesは`[%@][0-9]+`でunsigned numeric valueを使える．一時変数には丁度いいかもしれない．
3. constantsは長くなるので後で

予約語は色々あるので被らないように．でも`@%`で始まる予約語はないので衝突はしないよ．


```
%result = mul i32 %X, 8
%result = shl i32 %X, 3
%0 = shl i32 %X, %X
%1 = shl i32 %0, %0
%result = add i32 %1, %1
```

shlは左シフト演算のことか？
コンマ区切りが独特に感じる．どうせだったらmul，shl，addの後にもコンマを入れたらいいのにしていない．

1. コメントは`;`から始まりその行の終わりまで．
2. unnamedな一時変数は計算結果がnamed変数に代入されない時に使われる．
3. unnamed変数は通常連番が使われる．別にスキップしてもよさげ．

ノート:（下まで読まないと書いてあることが分からなさそうなのでここでは仮）
basic blockと無名関数の引数は0から始まる？


### 文字列定数

文字列は`"`で区切られる．`\`を使ってエスケープすれば全ての文字が扱える．

エスケープには2種類あって，


1. `\\`は`\`自身を表す
2. `\`から始まり2つの16進数文字，(0-9, a-f or A-F)はそのbyteの文字を表す


`"`自身を現したい場合は`\22`を使う．

また，文字列は改行によって終了しない．つまり複数行を受け取る．
(この場合改行は改行文字として入るのだろうか，それとも無視されるのだろうか)


## 高度な構造

### Module構造

LLVMのプログラムはModuleの集まりである．
それぞれのmoduleには関数，大域的変数，シンボルテーブルの要素が入っている．
そしてmodule同士はLLVM linkerによって繋げられる．
前方宣言とかシンボルテーブル要素の結合とかもいい感じにしてくれる．


hello worldのmoduleはこんな感じ

```
; 大域的定数で文字列を宣言．
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"

; puts関数を外部宣言
declare i32 @puts(ptr nocapture) nounwind

; main関数を定義
define i32 @main() {
  ; puts関数を呼び出してstdoutに出力
  call i32 @puts(ptr @.str)
  ret i32 0
}

; 名前付きメタデータ
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```

よく分からないものがいくつかある．`private, nounwind`あとコメントにある`named metadata`以下のやつは何を意味しているのか．

また一般に，moduleは大域的値(関数と変数)のリストからなる．
大域的値はメモリの場所へのポインタで表される．(上の例では文字配列へのポインターや関数へのポインター)


### リンケージ型

全ての大域的変数や関数は次の内のどれかのリンケージ型を持つ．
詳細の説明は全部書くと大変なので概要だけ．

- `private`
    - そのmodule内のオブジェクトからアクセスされる．
- `internal`
    - `private`と似ているが，オブジェクトファイルからは局所的シンボルとして見える．(C言語のstaticに相当)
- `avairable_externally`
    - このリンクを持つ大域的値はmoduleのオブジェクトファイルには出力されない．いわゆる外部宣言．定義する時だけ使われる．宣言には使ってはいけない．
- `linkonce`
    - 他のモジュールの同名の大域的値と同一に見做される．一度も参照されなかった場合破棄されうる．
- `weak`
    - `linkonce`と似ているが，参照がなかった場合でも破棄されない．
- `common`
    - `weak`と似ている．C言語で言う所の大域的スコープの`int X;`
- `appending`
    - 配列へのポインターの大域的変数だけに適用される．2つの大域的変数が一緒にリンクされた場合に，大域的配列が一緒に追加される．(?)使い道と意味がよく分からなかった．
- `extern_weak`
    - ELFオブジェクトファイルモデルに従う．シンボルはリンクされるまでは`weak`であり，リンクがない場合，そのシンボルは未定義ではなくnullになる．
- `linkonce_odr`, `weak_odr`
    - odrが付くと，すべての大域的値が同値であることを意味する．
- `external`
    - 上記の識別子が何も付かなかった場合は，これになる．リンクされた時も外から参照できるように解決される．


宣言する場合，`external`か`extern_weak`以外の指定はルール違反．

## 呼出規約

functions, calls，invokesはオプションを持ちうる．
動的な呼び出し元，呼び出し先の規約は一致している必要がある．さもなければその動作は未定義．
現在サポートされている呼出規約は以下の通りで，今後追加される予定．

- `ccc`
    - C言語の呼出規約で，他のオプションが指定されない限りデフォルトはこれ．
- `fastcc`
- `coldcc`
- `ghccc`
- `cc 11`
- `anyregcc`
- `preserve_mostcc`
- `preserve_allcc`
- `preserve_nonecc`
- `cxx_fast_tlscc`
- `tailllcc`
- `swiftcc`
- `swifttailcc`
- `cfguard_checkcc`
- `cc <n>`


## 表示スタイル

全ての大域的変数や関数は以下のどれかの表示スタイルを持つ．


- `default`
    - ELFオブジェクトファイルのフォーマットを使う．他のmoduleから宣言が見える．
- `hidden`
    - 同じオブジェクトからは参照できるが，それ以外からは見れない．つまり他のmoduleからは直接参照することができない．
- `protected`
    - シンボルは動的シンボルとして配置されるが，定義されたmodule内では局所的シンボルとして扱われる．他のmoduleからは上書きできない．


`internal`や`private`としてリンクされた場合は，`defaullt`の表示スタイルに設定しなくてはならない．


## DLLストレージクラス

全ての大域的変数，関数およびエイリアスは下記のどれか1つのDLLストレージクラスを持てる．


- `dllimport`
- `dllexport`

よく分からないがあまり関係がなさそうなので一旦スキップ

`internal`や`private`のシンボルがついたリンケージはDLLストレージクラスを持てない．


## スレッド局所的ストレージモデル

一旦無視


## ランタイムプリエンプション指定子

一旦無視

## 構造体型

LLVM IRは`identified`あるいは`literal`の構造体型の指定子を許可する．
Literal型は構造的に唯一だが，identified型は唯一ではない．
opaque strctural typeというのは前方宣言の型でまだ使えない．

一旦無視

## Non-Integralポインタ型

実験的な型らしいので一旦無視

## 大域的変数

大域的変数はコンパイル時にメモリが確保される．
大域的変数の定義時に初期化する必要がある．
他の変換ユニットで宣言された場合，初期化されていない場合がある．

大域的変数はlinkage typeを指定することができる．

大域的変数の定義や宣言はexplocit sectionや，optional explicit alignmentを指定できる．
もし定義と宣言で一致しなかった場合，動作は未定義となる．

大域的定数で宣言した場合，その値は変更されない．

LLVMはたとえ最終的に定義がなかったとしても，定数としてマークされた大域的変数を宣言できる．

中略
oo
オプションをもりもりできるので，こんな感じになる．


```
@G = addrspace(5) constant float 1.0, section "foo", align 4
@G = external global i32
@G = internal global i32 0, code_model "large"
@G = thread_local(initialexec) global i32 0, align 4
```

## 関数

関数の定義は`define`というキーワードを含む．
そしてオプションとしてlinkage型，ランタイムプリエンプション指定子，
表示スタイル，DLLストレージクラス，呼出規約，中略

関数の宣言は`declare`というキーワードを含む．中略．

関数定義CFG(Control Flow Graph)でできた，基本ブロックのリストで構成されている．
それぞれの基本ブロックはラベルから始まり，デバックレコードを含み，`terminator`で終了する(branchかあるいは関数の`return`)．
もし明示的なラベル名が与えられなかった場合は，ブロックには暗黙の番号ラベルが付与される．
カウンターを使って自動で連番に振られる？
もし数字のラベルが明示的に与えられた場合，それに対応するラベル番号が暗黙の内に使われる．

関数の中の最初の基本ブロックは2つの方法の中でも特別だ．
関数に入ってすぐに実行され，基本ブロックが実行される前のッブロックは存在しない．
そして，`PHI nodes`も持てない．

中略

## エイリアス

エイリアスは関数や変数と違って，新しいデータを作ることはない．

エイリアスは名前と大域的値や定数表現へのエイリアスのターゲットを持っている．

中略

## IFuncs

エイリアスと似ていて，新しいデータや関数を作らない．
ランタイム時に関数の呼び出しを解決する新しいシンボル．

中略

## Comdats

一旦省略

## 名前付きメタデータ

メタデータの集合．メタデータノード（メタデータ文字列ではなく）が唯一の有効なオペランド．

中略

何に使うのだろうか．


## パラメータ属性

関数の戻り値や角パラメータの型はパラメータ属性を持っている．
パラメータ属性は，関数の戻り値やパラメータについての追加の情報についてやりとりするために使われる．
パラメータ属性は，関数の一部として捉えられ，関数の型ではない．
したがって，異なるパラメータ属性を持つ関数であっても同じ型を持つ場合がある．

```
declare i32 @printf(ptr noalias nocapture, ...)
declare i32 @atoi(i8 zeroext)
declare signext i8 @returns_signed_char()
```

- `zeroext`
- `signext`
- `noext`
- `inreg`
- `byval(<ty>)`
- `byref(<ty>)`
- `preallocated(<ty>)`
- `inalloca(<ty>)`
- `sret(<ty>)`
- `elementtype(<ty>)`
- `align<n> or align(<n>)`
- `noalias`
- `nocapture`
- `nofree`
- `nest`
- `returned`
- `nonnull`
- `dereferenceable`
- `dereferenceable_or_null(<n>)`
- `swiftself`
- `swiftasync`
- `swifterror`
- `immarg`
- `noundef`
- `nofpclass(<test mask>)`
- `alignstack(<n>)`
- `allocalign`
- `allocptr`
- `readnone`
- `readonly`
- `writeonly`
- `writable`
- `initializes`
- `dead_on_unwind`
- `range(<ty> <a>, <b>)`

説明は省略

## ガベッジコレクター戦略名

省略

## プレフィックスデータ

省略

## プロローグデータ

省略

## 個人関数

省略

## 属性グループ

属性を保存しておくための機能?

```
; Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }

; Target-dependent attributes:
attributes #1 = { "no-sse" }

; Function @f has attributes: alwaysinline, alignstack=4, and "no-sse".
define void @f() #0 #1 { ... }
```

省略


## 関数属性

省略

## コールサイト属性

## 大域的属性


## モジュールレベルのインラインアセンブリ

## データレイアウト

## ターゲットトリプル

## オブジェクトの生存期間

## ポインタのエイリアスルール

## ポインタキャプチャ

## volatileメモリアクセス

## 並列処理のメモリモデル

## アトミックなメモリの順序制約

## 浮動小数点数の環境

## 浮動小数点数のNaN時の挙動

## Fast-Mathフラグ

## ユーザーリストの順序指定

## ソースのファル名

# 型システム

## void型

## 関数型

## 第一クラス型

### 単一値型

### ラベル型

### トークン型

### メタデータ型

### 集約型


# 定数

## 簡単な定数

## 複雑な定数

## 大域的変数と関数アドレス

## 未定義値

## 毒の値

## Well-definedな値

## 基本ブロックのアドレス

## DSOOの局所的同値性

## No CFI

## ポインタの認証定数

## 定数表現

# 他の値

## インラインアセンブリ表現

### インラインアセンブリの制約文字列

### アセンブリのテンプレート引数の修飾子

### インラインアセンブリのメタデータ

# メタデータ

# モジュールフラグのメタデータ

# 組込みオブジェクト名のメタデータ

# アトミックリンクのフラグの名前付きメタデータ

# 依存ライブラリの名前付きメタデータ

# ThinLTOのまとめ

# 本質的な大域的変数

# 本質的な参照

# 本質的な関数

